
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Overview &#8212; RLBox Sandboxing API  documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id5">Overview</a></p>
<ul>
<li><p><a class="reference internal" href="#example-library-sandboxing" id="id6">Example library sandboxing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#core-api" id="id7">Core API</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-and-destroying-sandboxes" id="id8">Creating (and destroying) sandboxes</a></p></li>
<li><p><a class="reference internal" href="#calling-sandboxed-library-functions" id="id9">Calling sandboxed library functions</a></p></li>
<li><p><a class="reference internal" href="#exposing-functions-to-sandboxed-code" id="id10">Exposing functions to sandboxed code</a></p></li>
<li><p><a class="reference internal" href="#tainted-values" id="id11">Tainted values</a></p>
<ul>
<li><p><a class="reference internal" href="#unwrapping-tainted-values" id="id12">Unwrapping tainted values</a></p></li>
<li><p><a class="reference internal" href="#operating-on-tainted-values" id="id13">Operating on tainted values</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#application-sandbox-shared-memory" id="id14">Application-sandbox shared memory</a></p></li>
<li><p><a class="reference internal" href="#standard-library" id="id15">Standard library</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id16">References</a></p></li>
<li><p><a class="reference internal" href="#indices-and-tables" id="id17">Indices and tables</a></p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id5">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<p>This is a short tutorial on the RLBox API. If you are looking for a reference
of all APIs, see <a class="reference internal" href="#doxygen" id="id1"><span>[Doxygen]</span></a>.</p>
<p>RLBox is a toolkit for sandboxing third-party libraries. The toolkit consists
of (1) a Wasm-based sandbox and (2) an API for retrofitting existing
application code to interface with a sandboxed library.  The Wasm-based sandbox
is documented in its <a class="reference external" href="https://wasm-sandbox.rlbox.dev">corresponding repository</a>.  This documentation focuses on
the API and the interface you will use when sandboxing code, independent of the
underlying sandboxing mechanism.</p>
<p><strong>Why do we need a sandboxing API?</strong>
Sandboxing libraries without the RLBox API is both tedious and error-prone.
This is especially the case when retrofitting an existing codebase like Firefox
where libraries are trusted and thus the application-library boundary is
blurry.  To sandbox a library – and thus to move to a world where the library
is no longer trusted – we need to modify this application-library boundary.
For example, we need to add security checks in Firefox to ensure that any value
from the sandboxed library is properly validated before it is used.  Otherwise,
the library (when compromised) may be able to abuse Firefox code to hijack its
control flow (see <a class="reference internal" href="#rlboxpaper" id="id2"><span>[RLBoxPaper]</span></a> for details). The RLBox API is explicitly
designed to make retrofitting of existing application code simpler and less
error-prone.</p>
<p><strong>Sandboxing architecture overview</strong> As shown in <a class="reference internal" href="#arch-fig"><span class="std std-numref">Fig. 1</span></a>, RLBox ensures that a
sandboxed library is <em>memory isolated</em> from the rest of the application – the
library cannot directly access memory outside its designated region – and that
all <em>boundary crossings are explicit</em>. This ensures that the library cannot,
for example, corrupt Firefox’s address space. It also ensures that Firefox
cannot inadvertently expose sensitive data to the library (e.g., pointers that
would leak its ASLR).</p>
<div class="figure align-center" id="id4">
<span id="arch-fig"></span><img alt="RLBox architecture" src="_images/arch.png" />
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Sandboxed libraries are isolated from the application and all communication
between the sandboxed library and application code is mediated. This ensures
that the application code is robust and does not use untrusted,
<a class="reference internal" href="#tainted"><span class="std std-ref">tainted values</span></a> without checking them.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Memory isolation is enforced by the underlying sandboxing mechanism (from the
start, when you create the sandbox with <a class="reference internal" href="#create-sandbox"><span class="std std-ref">create_sandbox()</span></a>). Explicit
boundary crossings are enforced by RLBox (either at compile- or and run-time).
For example, with RLBox you can’t call library functions directly; instead, you
must use the <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a> method. Similarly, the library cannot
call arbitrary Firefox functions; instead, it can only call functions that you
expose with the <a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a> method. (To
simplify the sandboxing task, though, RLBox does expose a standard library as
described in <a class="reference internal" href="#stdlib"><span class="std std-ref">Standard library</span></a>.)</p>
<p>When calling a library function, RLBox copies simple values into the sandbox
memory before calling the function. For larger data types, such as structs and
arrays, you can’t simply pass a pointer to the object. This would leak ASLR
and, more importantly, would not work: sandboxed code cannot access application
memory.  So, you must explicitly allocate memory in the sandbox via
<a class="reference internal" href="#malloc-in-sandbox"><span class="std std-ref">malloc_in_sandbox()</span></a> and copy application data to
this region of memory (e.g., via <code class="docutils literal notranslate"><span class="pre">strncpy</span></code>).</p>
<p>RLBox similarly copies simple return values and callback arguments. Larger data
structures, however, must (again) be passed by <em>sandbox-reference</em>, i.e., via a
reference/pointer to sandbox memory.</p>
<p>To ensure that application code doesn’t use values that originate in the
sandbox – and may thus be under the control of an attacker – unsafely, RLBox
considers all such values as untrusted and <a class="reference internal" href="#tainted"><span class="std std-ref">taints</span></a> them.
Tainted values are essentially opaque values (though RLBox does provide some
<a class="reference internal" href="#tainted-ops"><span class="std std-ref">basic operators on tainted values</span></a>). To use a tainted
value, you must unwrap it by copying the value into application memory – and
thus out of the reach of the attacker – and <em>verifying</em> it. Indeed, RLBox
forces application code to perform the copy and verification in sync using
<a class="reference internal" href="#verification"><span class="std std-ref">verifiction functions</span></a>.</p>
<div class="section" id="example-library-sandboxing">
<h2><a class="toc-backref" href="#id6">Example library sandboxing</a><a class="headerlink" href="#example-library-sandboxing" title="Permalink to this headline">¶</a></h2>
<p>To get a feel for what it’s like to use RLBox, we’re going to sandbox a tiny
library <code class="docutils literal notranslate"><span class="pre">mylib</span></code> that has four functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">mylib</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>

<span class="n">void</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Hello world from mylib</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">unsigned</span> <span class="n">add</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">echo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;&gt; mylib: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">call_cb</span><span class="p">(</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">str</span><span class="p">))</span> <span class="p">{</span>
   <span class="n">cb</span><span class="p">(</span><span class="s2">&quot;hi again!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not the most interesting library, security-wise, but it is complicated
enough to demonstrate various RLBox features.</p>
<p>To get started, in our main application file let’s first import the RLBox
library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">main</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span>

<span class="c1">#define RLBOX_SINGLE_THREADED_INVOCATIONS</span>
<span class="c1">#define RLBOX_USE_STATIC_CALLS() rlbox_noop_sandbox_lookup_symbol</span>

<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &quot;mylib.h&quot;</span>
<span class="c1">#include &quot;rlbox.hpp&quot;</span>
<span class="c1">#include &quot;rlbox_noop_sandbox.hpp&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">rlbox</span><span class="p">;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In our main function, let’s now create a new sandbox (for this example we’re
going to use the NULL sandbox) and call the <code class="docutils literal notranslate"><span class="pre">hello</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">sandbox</span>
   <span class="n">rlbox</span><span class="p">::</span><span class="n">rlbox_sandbox</span><span class="o">&lt;</span><span class="n">rlbox_noop_sandbox</span><span class="o">&gt;</span> <span class="n">sandbox</span><span class="p">;</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">create_sandbox</span><span class="p">();</span>

   <span class="o">//</span> <span class="n">call</span> <span class="n">the</span> <span class="n">library</span> <span class="n">hello</span> <span class="n">function</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Note that we do not call <code class="docutils literal notranslate"><span class="pre">hello()</span></code> directly. Instead, we use the
<a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a> method. We can similarly call the
<code class="docutils literal notranslate"><span class="pre">add</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="o">//</span> <span class="n">call</span> <span class="n">the</span> <span class="n">add</span> <span class="n">function</span> <span class="ow">and</span> <span class="n">check</span> <span class="n">the</span> <span class="n">result</span><span class="p">:</span>
   <span class="n">auto</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">copy_and_verify</span><span class="p">([](</span><span class="n">unsigned</span> <span class="n">ret</span><span class="p">){</span>
         <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Adding... 3+4 = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
   <span class="p">});</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;OK? = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ok</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This invocation is a bit more interesting. First, we call <code class="docutils literal notranslate"><span class="pre">add</span></code> with
arguments. Second, RLBox ensures that the <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> return value that
<code class="docutils literal notranslate"><span class="pre">add</span></code> returns is <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> and thus cannot be used without
verification. Here, we call the copy_and_verify
function which copies the value into application memory and runs our verifier
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[](</span><span class="n">unsigned</span> <span class="n">ret</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Adding... 3+4 = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This lambda simply prints the tainted value and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it is
<code class="docutils literal notranslate"><span class="pre">7</span></code>. A compromised library could return any value and if we use this value
to, say, index an array this could potentially introduce an out-of-bounds
memory access.</p>
<p>Let’s now call the <code class="docutils literal notranslate"><span class="pre">echo</span></code> function which takes a slightly more interesting
argument: a string. Here, we can’t simply pass a string literal as an argument:
the sandbox cannot access application memory where this would be allocated.
Instead, we must allocate a buffer in sandbox memory and copy the string we
want to pass to <code class="docutils literal notranslate"><span class="pre">echo</span></code> into this region:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">helloStr</span> <span class="o">=</span> <span class="s2">&quot;hi hi!&quot;</span><span class="p">;</span>
   <span class="n">size_t</span> <span class="n">helloSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">helloStr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="o">//</span> <span class="n">allocate</span> <span class="n">memory</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">sandbox</span><span class="p">:</span>
   <span class="n">auto</span> <span class="n">taintedStr</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">malloc_in_sandbox</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">helloSize</span><span class="p">);</span>
   <span class="o">//</span> <span class="n">copy</span> <span class="n">helloStr</span> <span class="n">into</span> <span class="n">the</span> <span class="n">sandbox</span><span class="p">:</span>
   <span class="n">std</span><span class="p">::</span><span class="n">strncpy</span><span class="p">(</span><span class="n">taintedStr</span><span class="o">.</span><span class="n">unverified_safe_pointer_because</span><span class="p">(</span><span class="n">helloSize</span><span class="p">,</span> <span class="s2">&quot;writing to region&quot;</span><span class="p">),</span> <span class="n">helloStr</span><span class="p">,</span> <span class="n">helloSize</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">taintedStr</span></code> is actually a <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> string: it
lives in the sandbox memory and could be written to by the (compromised)
library code concurrently. As such, it’s unsafe for us to use this pointer
without verification. Above, we use the “unverified_safe_pointer_because”
verifier which basically removes the taint without
any verification. This is safe because we copy the <code class="docutils literal notranslate"><span class="pre">helloStr</span></code> to sandbox
memory: at worst, the sandboxed library can overwrite the memory region pointed
to by <code class="docutils literal notranslate"><span class="pre">taintedStr</span></code> and crash when it tries to print it.</p>
<p>Now, we can just call the function and free the allocated string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="n">taintedStr</span><span class="p">);</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">free_in_sandbox</span><span class="p">(</span><span class="n">taintedStr</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Finally, let’s call the <code class="docutils literal notranslate"><span class="pre">call_cb</span></code> function. To do this, let’s first define a
callback for the function to call. We define this function above the <code class="docutils literal notranslate"><span class="pre">main</span></code>
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>...
void hello_cb(rlbox_sandbox&lt;rlbox_noop_sandbox&gt;&amp; _,
            tainted&lt;const char*, rlbox_noop_sandbox&gt; str) {
   auto checked_string =
      str.copy_and_verify_string([](std::unique_ptr&lt;char[]&gt; val) {
         return std::strlen(val.get()) &lt; 1024 ? std::move(val) : nullptr;
      });
   printf(&quot;hello_cb: %s\n&quot;, checked_string.get());
}
...
</pre></div>
</div>
<p>This callback is called with a string. We thus call the <a class="reference internal" href="#copy-and-verify-string"><span class="std std-ref">string
verification function</span></a> with a simple verifier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>...
   [](std::unique_ptr&lt;char[]&gt; val) {
        return std::strlen(val.get()) &lt; 1024 ? std::move(val) : nullptr;
    }
...
</pre></div>
</div>
<p>This verifier moves the string if it’s length is less than 1KB and otherwise
returns the <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. In the callback we simply print this (potentially
null) string.</p>
<p>Let’s now continue in <code class="docutils literal notranslate"><span class="pre">main</span></code>, register the callback – otherwise RLBox will
disallow the library-application call – and pass the callback to the
<code class="docutils literal notranslate"><span class="pre">call_cb</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="o">//</span> <span class="n">register</span> <span class="n">callback</span> <span class="ow">and</span> <span class="n">call</span> <span class="n">it</span>
   <span class="n">auto</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">hello_cb</span><span class="p">);</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">call_cb</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Finally, let’s destroy the sandbox and exit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="o">//</span> <span class="n">destroy</span> <span class="n">sandbox</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">destroy_sandbox</span><span class="p">();</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="core-api">
<h1><a class="toc-backref" href="#id7">Core API</a><a class="headerlink" href="#core-api" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe a large part of the RLBox API you are likely to
encounter when porting libraries. The API has some more advanced features and
types that are necessary but not as commonly used (see <a class="reference internal" href="#doxygen" id="id3"><span>[Doxygen]</span></a>).  In most
cases the RLBox type system will give you an informative error if and how to
use these features.</p>
<div class="section" id="creating-and-destroying-sandboxes">
<h2><a class="toc-backref" href="#id8">Creating (and destroying) sandboxes</a><a class="headerlink" href="#creating-and-destroying-sandboxes" title="Permalink to this headline">¶</a></h2>
<p>RLBox encapsulates sandboxes with <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">rlbox_sandbox</span></a> class.
For now, RLBox supports two sandboxes: a Wasm-based sandboxed and the <em>null</em>
sandbox. The null sandbox doesn’t actually enforce any isolation, but is very
useful for migrating an existing codebase to use the RLBox API.  In fact, in
most cases you want to port the existing code to use RLBox when interfacing
with a particular library and only then switch over to the Wasm-based sandbox.</p>
<div class="admonition warning" id="rlbox-sandbox">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning" id="create-sandbox">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>Creating sandboxes is mostly straightforward.  For the null sandbox, however,
you need to add a <code class="docutils literal notranslate"><span class="pre">#define</span></code> at the top of your entry file, before you include
the RLBox headers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define RLBOX_USE_STATIC_CALLS() rlbox_noop_sandbox_lookup_symbol</span>
<span class="o">...</span>
<span class="n">rlbox</span><span class="p">::</span><span class="n">rlbox_sandbox</span><span class="o">&lt;</span><span class="n">rlbox_noop_sandbox</span><span class="o">&gt;</span> <span class="n">sandbox</span><span class="p">;</span>
<span class="n">sandbox</span><span class="o">.</span><span class="n">create_sandbox</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition warning" id="destroy-sandbox">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>It’s important to destroy a sandbox after you are done with it. This ensures
that the memory footprint of sandboxing remains low. Once you destroy a sandbox
though, it is an error to use the sandbox object.</p>
</div>
<div class="section" id="calling-sandboxed-library-functions">
<h2><a class="toc-backref" href="#id9">Calling sandboxed library functions</a><a class="headerlink" href="#calling-sandboxed-library-functions" title="Permalink to this headline">¶</a></h2>
<p>RLBox disallows code from calling sandboxed library functions directly.
Instead, application code must use the <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a>
method.</p>
<div class="admonition warning" id="invoke-sandbox-function">
<p class="admonition-title">Warning</p>
<p>doxygendefine: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>Though this function is defined via macros, RLBox uses some template and macro
magic to make this look like a <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">sandbox</span></a> method. So, in
general, you can call sandboxed library functions as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">call</span> <span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="exposing-functions-to-sandboxed-code">
<h2><a class="toc-backref" href="#id10">Exposing functions to sandboxed code</a><a class="headerlink" href="#exposing-functions-to-sandboxed-code" title="Permalink to this headline">¶</a></h2>
<p>Application code can expose <a class="reference internal" href="#callback"><span class="std std-ref">callback functions</span></a> to sandbox via
<a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a>.  These functions can be called
by the sandboxed code until they are <a class="reference internal" href="#unregister-callback"><span class="std std-ref">unregistered</span></a>.</p>
<p id="register-callback">The type signatures of <a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a>
function is a bit daunting. In short, the function takes a <a class="reference internal" href="#callback"><span class="std std-ref">callback
function</span></a> and returns a function pointer that can be passed to the
sandbox (e.g., via <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a>).</p>
<p id="callback">A <em>callback function</em> is a function that has a special type:</p>
<ul class="simple">
<li><p>The first argument of the function must be a reference a <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">sandbox</span></a> object.</p></li>
<li><p>The remaining arguments must be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a>.</p></li>
<li><p>The return value must be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> or <code class="docutils literal notranslate"><span class="pre">void</span></code>. This ensures
that the application cannot accidentally leak data to the sandbox.</p></li>
</ul>
<p>Forcing arguments to be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> forces the application to
handled values coming from the sandbox with care. Dually, the return type
ensures that the application cannot accidentally leak data to the sandbox.</p>
<div class="admonition warning" id="unregister-callback">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
</div>
<div class="section" id="tainted-values">
<h2><a class="toc-backref" href="#id11">Tainted values</a><a class="headerlink" href="#tainted-values" title="Permalink to this headline">¶</a></h2>
<p>Values that originate in the sandbox are <em>tainted</em>. We use a special tainted
type <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> to encapsulate such values and prevent the
application from using tainted values unsafely.</p>
<div class="admonition warning" id="tainted">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>RLBox has several kinds of tainted values, beyond <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a>.
Thse, however, are slightly less pervasive in the surface API.</p>
<div class="admonition warning" id="tainted-volatile">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning" id="tainted-boolean-hint">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="section" id="unwrapping-tainted-values">
<span id="verification"></span><h3><a class="toc-backref" href="#id12">Unwrapping tainted values</a><a class="headerlink" href="#unwrapping-tainted-values" title="Permalink to this headline">¶</a></h3>
<p>To use tainted values, the application can copy
the value to application memory, verify the value, and unwrap it. RLBox
provides several functions to do this.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>For a given tainted type, the verifier should have the following signature:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 21%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tainted type kind</p></th>
<th class="head"><p>Example type</p></th>
<th class="head"><p>Example verifier</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Simple type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(int)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer to simple type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(unique_ptr&lt;int&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Pointer to class type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(unique_ptr&lt;Foo&gt;)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer to array</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int[4]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(std::array&lt;int,</span> <span class="pre">4&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Class type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(tainted&lt;Foo&gt;)</span></code></p></td>
</tr>
</tbody>
</table>
<p>In general, the return type of the verifier <code class="docutils literal notranslate"><span class="pre">T_Ret</span></code> is not constrained and can
be anything the caller chooses.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning" id="copy-and-verify-string">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>In some cases it’s useful to unwrap tainted values without verification.
Sometimes this is safe to do and RLBox provides a method for doing so
called <code class="docutils literal notranslate"><span class="pre">unverified_safe_because</span></code></p>
<p>Since pointers are special (sandbox code may modify the data the pointer
points to), we have a similar function for pointers called
unverified_safe_pointer_because. This API requires specifying the number of
elements being pointed to for safety.</p>
<p>We however provide additional functions that are especially useful during
migration:</p>
<div class="admonition warning" id="unsafe-unverified">
<p class="admonition-title">Warning</p>
<p>doxygenclass: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p>These functions are also available for <a class="reference internal" href="#callback"><span class="std std-ref">callback</span></a></p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>Unchecked unwrapped tainted values can be abused by a compromised
or malicious library to potentially compromise the application.</p>
</div>
</div>
<div class="section" id="operating-on-tainted-values">
<span id="tainted-ops"></span><h3><a class="toc-backref" href="#id13">Operating on tainted values</a><a class="headerlink" href="#operating-on-tainted-values" title="Permalink to this headline">¶</a></h3>
<p>Unwrapping tainted values requires care – getting a verifier wrong could lead
to a security vulnerability. It’s also not cheap: we need to copy data to the
application memory to ensure that the sandboxed code cannot modify the data
we’re tyring to verify. Lucikly, it’s not always necessary to copy and verify:
sometimes we can compute on tainted values directly. To this end, RLBox defines
different kinds of operators on tainted values, which produce tainted values.
This allows you to perform some computations on tainted values, pass the values
back into the sandbox, and only later unwrap a tainted value when you need to.
operators like <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> on tainted values.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Class of operator</p></th>
<th class="head"><p>Supported operators</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Arithmetic operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>,
<code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Relational operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Logical operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (limited), <code class="docutils literal notranslate"><span class="pre">||</span></code> (limited)</p></td>
</tr>
<tr class="row-odd"><td><p>Bitwise operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Compound operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>,
<code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code></p></td>
</tr>
</tbody>
</table>
<p>When applying a binary operator like <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> to a tainted value and an untainted
values the result is always tainted.</p>
<p>RLBox also defines several comparison operators on tainted values that sometime
unwrap the result:</p>
<ul class="simple">
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code> on tainted pointers is allowed if the rhs is <code class="docutils literal notranslate"><span class="pre">nullptr_t</span></code> and return unwrapped <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>Operator <code class="docutils literal notranslate"><span class="pre">!</span></code> on tainted pointers retruns an unwrapped <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> on non-pointer tainted values return a <code class="docutils literal notranslate"><span class="pre">tainted&lt;bool&gt;</span></code></p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> on <a class="reference internal" href="#tainted-volatile"><span class="std std-ref">tainted_volatile</span></a> values returns a <a class="reference internal" href="#tainted-boolean-hint"><span class="std std-ref">tainted_boolean_hint</span></a></p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> on booleans are only permitted when arguments are variables (not expressions). This is because C++ does not permit safe overloading of &amp;&amp; and || operations with expression arguments as this affects the short circuiting behaviour of these operations.</p></li>
</ul>
</div>
</div>
<div class="section" id="application-sandbox-shared-memory">
<h2><a class="toc-backref" href="#id14">Application-sandbox shared memory</a><a class="headerlink" href="#application-sandbox-shared-memory" title="Permalink to this headline">¶</a></h2>
<p>Since sandboxed code cannot access application memory, to share objects across
the boundary you need to explicitly allocate memory that both the application
and sandbox can access. To this end, <a class="reference internal" href="#malloc-in-sandbox"><span class="std std-ref">malloc_in_sandbox()</span></a> allocates memory within the sandbox region and returns a
<a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> pointer that can be used by both the application and
sandbox (e.g., by passing the pointer as an argument to a function).</p>
<div class="admonition warning" id="malloc-in-sandbox">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<p id="free-in-sandbox">To distinguish between different pointer types, RLBox also provides some helper functions:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
</div>
<div class="section" id="standard-library">
<span id="stdlib"></span><h2><a class="toc-backref" href="#id15">Standard library</a><a class="headerlink" href="#standard-library" title="Permalink to this headline">¶</a></h2>
<p>RLBox provides several helper functions to application for handling sandboxed
memory regions and values.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: breathe_default_project value ‘RLBox’ does not seem to be a valid key for the breathe_projects dictionary</p>
</div>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id16">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<dl class="citation">
<dt class="label" id="rlboxpaper"><span class="brackets"><a class="fn-backref" href="#id2">RLBoxPaper</a></span></dt>
<dd><p><a class="reference external" href="https://usenix2020.rlbox.dev">*Retrofitting Fine Grain Isolation in the Firefox Renderer*. S. Narayan, C. Disselkoen, T. Garfinkel, S. Lerner, H. Shacham, D. Stefan.</a></p>
</dd>
<dt class="label" id="doxygen"><span class="brackets">Doxygen</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://doxygen.rlbox.dev/">RLBox Doxygen Documentation</a></p>
</dd>
</dl>
</div>
<div class="section" id="indices-and-tables">
<h1><a class="toc-backref" href="#id17">Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">RLBox Sandboxing API</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, RLBox_AUTHOR.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>