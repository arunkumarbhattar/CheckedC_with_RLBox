\hypertarget{rlbox_8hpp_source}{}\doxysection{rlbox.\+hpp}
\label{rlbox_8hpp_source}\index{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox.hpp@{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}rlbox\_app\_pointer.hpp"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}rlbox\_conversion.hpp"{}}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}rlbox\_helpers.hpp"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}rlbox\_policy\_types.hpp"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}rlbox\_range.hpp"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}rlbox\_sandbox.hpp"{}}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include "{}rlbox\_stdlib.hpp"{}}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}rlbox\_struct\_support.hpp"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}rlbox\_type\_traits.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}rlbox\_types.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}rlbox\_unwrap.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}rlbox\_wrapper\_traits.hpp"{}}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{namespace }rlbox \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{typename} T\_Wrap,}
\DoxyCodeLine{25          \textcolor{keyword}{typename} T,}
\DoxyCodeLine{26          \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{27 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl}}}
\DoxyCodeLine{28 \{}
\DoxyCodeLine{29   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{30   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{public}:}
\DoxyCodeLine{33   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& impl() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T\_Wrap<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}}
\DoxyCodeLine{34   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& impl()\textcolor{keyword}{ const}}
\DoxyCodeLine{35 \textcolor{keyword}{  }\{}
\DoxyCodeLine{36     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }T\_Wrap<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this});}
\DoxyCodeLine{37   \}}
\DoxyCodeLine{38 }
\DoxyCodeLine{43   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}() \{ \textcolor{keywordflow}{return} impl().get\_raw\_value(); \}}
\DoxyCodeLine{44   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl().get\_raw\_value(); \}}
\DoxyCodeLine{54   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox)}
\DoxyCodeLine{55   \{}
\DoxyCodeLine{56     \textcolor{keywordflow}{return} impl().get\_raw\_sandbox\_value(sandbox);}
\DoxyCodeLine{57   \}}
\DoxyCodeLine{58   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox)\textcolor{keyword}{ const}}
\DoxyCodeLine{59 \textcolor{keyword}{  }\{}
\DoxyCodeLine{60     \textcolor{keywordflow}{return} impl().get\_raw\_sandbox\_value(sandbox);}
\DoxyCodeLine{61   \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{69   \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}{rlbox\_detail\_member\_and\_const}}(}
\DoxyCodeLine{70     template<size\_t N>}
\DoxyCodeLine{71     \textcolor{keyword}{inline} \textcolor{keyword}{auto} unverified\_safe\_because(\textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N]),}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73       RLBOX\_UNUSED(reason);}
\DoxyCodeLine{74       \textcolor{keyword}{static\_assert}(!std::is\_pointer\_v<T>,}
\DoxyCodeLine{75                     \textcolor{stringliteral}{"{}unverified\_safe\_because does not support pointers. Use "{}}}
\DoxyCodeLine{76                     \textcolor{stringliteral}{"{}unverified\_safe\_pointer\_because."{}});}
\DoxyCodeLine{77       \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}();}
\DoxyCodeLine{78     \});}
\DoxyCodeLine{79 }
\DoxyCodeLine{80   \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}{rlbox\_detail\_member\_and\_const}}(}
\DoxyCodeLine{81     template<size\_t N>}
\DoxyCodeLine{82     \textcolor{keyword}{inline} \textcolor{keyword}{auto} unverified\_safe\_pointer\_because(\textcolor{keywordtype}{size\_t} count,}
\DoxyCodeLine{83                                                 \textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N]),}
\DoxyCodeLine{84     \{}
\DoxyCodeLine{85       RLBOX\_UNUSED(reason);}
\DoxyCodeLine{86 }
\DoxyCodeLine{87       \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>, \textcolor{stringliteral}{"{}Expected pointer type"{}});}
\DoxyCodeLine{88       \textcolor{keyword}{using} T\_Pointed = std::remove\_pointer\_t<T>;}
\DoxyCodeLine{89       if\_constexpr\_named(cond1, std::is\_pointer\_v<T\_Pointed>)}
\DoxyCodeLine{90       \{}
\DoxyCodeLine{91         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{92           cond1,}
\DoxyCodeLine{93           \textcolor{stringliteral}{"{}There is no way to use unverified\_safe\_pointer\_because for "{}}}
\DoxyCodeLine{94           \textcolor{stringliteral}{"{}'pointers to pointers' safely. Use copy\_and\_verify instead."{}});}
\DoxyCodeLine{95         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{96       \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98       \textcolor{keyword}{auto} ret = \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}();}
\DoxyCodeLine{99       \textcolor{keywordflow}{if} (ret != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{100         \textcolor{keywordtype}{size\_t} bytes = \textcolor{keyword}{sizeof}(T) * count;}
\DoxyCodeLine{101         detail::check\_range\_doesnt\_cross\_app\_sbx\_boundary<T\_Sbx>(ret, bytes);}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103       \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{104     \});}
\DoxyCodeLine{105 }
\DoxyCodeLine{106   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}(); \}}
\DoxyCodeLine{107   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}(); \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{preprocessor}{\#define BinaryOpValAndPtr(opSymbol)                                            \(\backslash\)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{111 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{112 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{113 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{114 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{115 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{116 \textcolor{preprocessor}{    static\_assert(detail::is\_basic\_type\_v<T>,                                  \(\backslash\)}}
\DoxyCodeLine{117 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{118                   "{} only supported for primitive and pointer types"{});          \(\backslash\)}
\DoxyCodeLine{119                                                                                \(\backslash\)}
\DoxyCodeLine{120     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{121                                                                                \(\backslash\)}
\DoxyCodeLine{122     if constexpr (std::is\_pointer\_v<T>) \{                                      \(\backslash\)}
\DoxyCodeLine{123       static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                     \(\backslash\)}
\DoxyCodeLine{124                     "{}Can only operate on numeric types"{});                      \(\backslash\)}
\DoxyCodeLine{125       auto ptr = impl().get\_raw\_value();                                       \(\backslash\)}
\DoxyCodeLine{126       detail::dynamic\_check(ptr != nullptr,                                    \(\backslash\)}
\DoxyCodeLine{127                             "{}Pointer arithmetic on a null pointer"{});           \(\backslash\)}
\DoxyCodeLine{128       \textcolor{comment}{/* increment the target by size of the data structure */}\textcolor{preprocessor}{                 \(\backslash\)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{      auto target =                                                            \(\backslash\)}}
\DoxyCodeLine{130 \textcolor{preprocessor}{        reinterpret\_cast<uintptr\_t>(ptr) opSymbol raw\_rhs * sizeof(*impl());   \(\backslash\)}}
\DoxyCodeLine{131 \textcolor{preprocessor}{      auto no\_overflow = rlbox\_sandbox<T\_Sbx>::is\_in\_same\_sandbox(             \(\backslash\)}}
\DoxyCodeLine{132 \textcolor{preprocessor}{        reinterpret\_cast<const void*>(ptr),                                    \(\backslash\)}}
\DoxyCodeLine{133 \textcolor{preprocessor}{        reinterpret\_cast<const void*>(target));                                \(\backslash\)}}
\DoxyCodeLine{134 \textcolor{preprocessor}{      detail::dynamic\_check(                                                   \(\backslash\)}}
\DoxyCodeLine{135 \textcolor{preprocessor}{        no\_overflow,                                                           \(\backslash\)}}
\DoxyCodeLine{136 \textcolor{preprocessor}{        "{}Pointer arithmetic overflowed a pointer beyond sandbox memory"{}});      \(\backslash\)}
\DoxyCodeLine{137                                                                                \(\backslash\)}
\DoxyCodeLine{138       return tainted<T, T\_Sbx>::internal\_factory(reinterpret\_cast<T>(target)); \(\backslash\)}
\DoxyCodeLine{139     \} else \{                                                                   \(\backslash\)}
\DoxyCodeLine{140       auto raw = impl().get\_raw\_value();                                       \(\backslash\)}
\DoxyCodeLine{141       auto ret = raw opSymbol raw\_rhs;                                         \(\backslash\)}
\DoxyCodeLine{142       using T\_Ret = decltype(ret);                                             \(\backslash\)}
\DoxyCodeLine{143       return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                     \(\backslash\)}
\DoxyCodeLine{144     \}                                                                          \(\backslash\)}
\DoxyCodeLine{145   \}                                                                            \(\backslash\)}
\DoxyCodeLine{146   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{147 }
\DoxyCodeLine{148   BinaryOpValAndPtr(+);}
\DoxyCodeLine{149   BinaryOpValAndPtr(-\/);}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{preprocessor}{\#undef BinaryOpValAndPtr}}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{preprocessor}{\#define BinaryOp(opSymbol)                                                     \(\backslash\)}}
\DoxyCodeLine{154 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{155 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{156 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{157 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{158 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{159 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{160 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{161 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{162                   "{} only supported for primitive  types"{});                     \(\backslash\)}
\DoxyCodeLine{163                                                                                \(\backslash\)}
\DoxyCodeLine{164     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{165     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{166     static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                       \(\backslash\)}
\DoxyCodeLine{167                   "{}Can only operate on numeric types"{});                        \(\backslash\)}
\DoxyCodeLine{168                                                                                \(\backslash\)}
\DoxyCodeLine{169     auto ret = raw opSymbol raw\_rhs;                                           \(\backslash\)}
\DoxyCodeLine{170     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{171     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{172   \}                                                                            \(\backslash\)}
\DoxyCodeLine{173   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{174 }
\DoxyCodeLine{175   BinaryOp(*);}
\DoxyCodeLine{176   BinaryOp(/);}
\DoxyCodeLine{177   BinaryOp(\%);}
\DoxyCodeLine{178   BinaryOp(\string^);}
\DoxyCodeLine{179   BinaryOp(\&);}
\DoxyCodeLine{180   BinaryOp(|);}
\DoxyCodeLine{181   BinaryOp(<<);}
\DoxyCodeLine{182   BinaryOp(>>);}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{preprocessor}{\#undef BinaryOp}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{preprocessor}{\#define CompoundAssignmentOp(opSymbol)                                         \(\backslash\)}}
\DoxyCodeLine{187 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{188 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx>\& operator opSymbol\#\#=(const T\_Rhs\& rhs)    \(\backslash\)}}
\DoxyCodeLine{189 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{190 \textcolor{preprocessor}{    auto\& this\_ref = impl();                                                   \(\backslash\)}}
\DoxyCodeLine{191 \textcolor{preprocessor}{    this\_ref = this\_ref opSymbol rhs;                                          \(\backslash\)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{    return this\_ref;                                                           \(\backslash\)}}
\DoxyCodeLine{193 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{194 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196   CompoundAssignmentOp(+);}
\DoxyCodeLine{197   CompoundAssignmentOp(-\/);}
\DoxyCodeLine{198   CompoundAssignmentOp(*);}
\DoxyCodeLine{199   CompoundAssignmentOp(/);}
\DoxyCodeLine{200   CompoundAssignmentOp(\%);}
\DoxyCodeLine{201   CompoundAssignmentOp(\string^);}
\DoxyCodeLine{202   CompoundAssignmentOp(\&);}
\DoxyCodeLine{203   CompoundAssignmentOp(|);}
\DoxyCodeLine{204   CompoundAssignmentOp(<<);}
\DoxyCodeLine{205   CompoundAssignmentOp(>>);}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{preprocessor}{\#undef CompoundAssignmentOp}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{preprocessor}{\#define PreIncDecOps(opSymbol)                                                 \(\backslash\)}}
\DoxyCodeLine{210 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx>\& operator opSymbol\#\#opSymbol()             \(\backslash\)}}
\DoxyCodeLine{211 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{212 \textcolor{preprocessor}{    auto\& this\_ref = impl();                                                   \(\backslash\)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{    this\_ref = this\_ref opSymbol 1;                                            \(\backslash\)}}
\DoxyCodeLine{214 \textcolor{preprocessor}{    return this\_ref;                                                           \(\backslash\)}}
\DoxyCodeLine{215 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{216 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218   PreIncDecOps(+);}
\DoxyCodeLine{219   PreIncDecOps(-\/);}
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{preprocessor}{\#undef PreIncDecOps}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{preprocessor}{\#define PostIncDecOps(opSymbol)                                                \(\backslash\)}}
\DoxyCodeLine{224 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx> operator opSymbol\#\#opSymbol(int)           \(\backslash\)}}
\DoxyCodeLine{225 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{226 \textcolor{preprocessor}{    tainted<T, T\_Sbx> ret = impl();                                            \(\backslash\)}}
\DoxyCodeLine{227 \textcolor{preprocessor}{    operator++();                                                              \(\backslash\)}}
\DoxyCodeLine{228 \textcolor{preprocessor}{    return ret;                                                                \(\backslash\)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{230 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232   PostIncDecOps(+);}
\DoxyCodeLine{233   PostIncDecOps(-\/);}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 \textcolor{preprocessor}{\#undef PostIncDecOps}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 \textcolor{preprocessor}{\#define BooleanBinaryOp(opSymbol)                                              \(\backslash\)}}
\DoxyCodeLine{238 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{239 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{240 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{241 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{242 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{243 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{244 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{245 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{246                   "{} only supported for primitive  types"{});                     \(\backslash\)}
\DoxyCodeLine{247                                                                                \(\backslash\)}
\DoxyCodeLine{248     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{249     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{250     static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                       \(\backslash\)}
\DoxyCodeLine{251                   "{}Can only operate on numeric types"{});                        \(\backslash\)}
\DoxyCodeLine{252                                                                                \(\backslash\)}
\DoxyCodeLine{253     auto ret = raw opSymbol raw\_rhs;                                           \(\backslash\)}
\DoxyCodeLine{254     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{255     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{256   \}                                                                            \(\backslash\)}
\DoxyCodeLine{257                                                                                \(\backslash\)}
\DoxyCodeLine{258   template<typename T\_Rhs>                                                     \(\backslash\)}
\DoxyCodeLine{259   inline constexpr auto operator opSymbol(const T\_Rhs\&\&)                       \(\backslash\)}
\DoxyCodeLine{260     const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}
\DoxyCodeLine{261                             detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}
\DoxyCodeLine{262                    T\_Sbx>                                                      \(\backslash\)}
\DoxyCodeLine{263   \{                                                                            \(\backslash\)}
\DoxyCodeLine{264     rlbox\_detail\_static\_fail\_because(                                          \(\backslash\)}
\DoxyCodeLine{265       detail::true\_v<T\_Rhs>,                                                   \(\backslash\)}
\DoxyCodeLine{266       "{}C++ does not permit safe overloading of \&\& and || operations as this "{}  \(\backslash\)}
\DoxyCodeLine{267       "{}affects the short circuiting behaviour of these operations. RLBox "{}     \(\backslash\)}
\DoxyCodeLine{268       "{}does let you use \&\& and || with tainted in limited situations -\/ when "{}  \(\backslash\)}
\DoxyCodeLine{269       "{}all arguments starting from the second are local variables. It does "{}   \(\backslash\)}
\DoxyCodeLine{270       "{}not allow it if arguments starting from the second  are expressions.\(\backslash\)n"{} \(\backslash\)}
\DoxyCodeLine{271       "{}For example the following is not allowed\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{272       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{273       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{274       "{}auto r = a \&\& true \&\& sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}      \(\backslash\)}
\DoxyCodeLine{275       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{276       "{}However the following would be allowed\(\backslash\)n"{}                               \(\backslash\)}
\DoxyCodeLine{277       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{278       "{}auto b = true\(\backslash\)n"{}                                                        \(\backslash\)}
\DoxyCodeLine{279       "{}auto c = sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}                   \(\backslash\)}
\DoxyCodeLine{280       "{}auto r = a \&\& b \&\& c;\(\backslash\)n"{}                                                \(\backslash\)}
\DoxyCodeLine{281       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{282       "{}Note that these 2 programs are not identical. The first program may "{}   \(\backslash\)}
\DoxyCodeLine{283       "{}or may not call getBool, while second program always calls getBool"{});   \(\backslash\)}
\DoxyCodeLine{284     return tainted<bool, T\_Sbx>(false);                                        \(\backslash\)}
\DoxyCodeLine{285   \}                                                                            \(\backslash\)}
\DoxyCodeLine{286   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{287 }
\DoxyCodeLine{288   BooleanBinaryOp(\&\&);}
\DoxyCodeLine{289   BooleanBinaryOp(||);}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{preprocessor}{\#undef BooleanBinaryOp}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{preprocessor}{\#define UnaryOp(opSymbol)                                                      \(\backslash\)}}
\DoxyCodeLine{294 \textcolor{preprocessor}{  inline auto operator opSymbol()                                              \(\backslash\)}}
\DoxyCodeLine{295 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{296 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{297 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol "{} only supported for primitive"{});      \(\backslash\)}
\DoxyCodeLine{298                                                                                \(\backslash\)}
\DoxyCodeLine{299     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{300     auto ret = opSymbol raw;                                                   \(\backslash\)}
\DoxyCodeLine{301     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{302     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{303   \}                                                                            \(\backslash\)}
\DoxyCodeLine{304   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{305 }
\DoxyCodeLine{306   UnaryOp(-\/);}
\DoxyCodeLine{307   UnaryOp(\string~);}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{preprocessor}{\#undef UnaryOp}}
\DoxyCodeLine{310 }
\DoxyCodeLine{321 \textcolor{preprocessor}{\#define CompareOp(opSymbol, permit\_pointers)                                   \(\backslash\)}}
\DoxyCodeLine{322 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{323 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs) const              \(\backslash\)}}
\DoxyCodeLine{324 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{325 \textcolor{preprocessor}{    using T\_RhsNoQ = detail::remove\_cv\_ref\_t<T\_Rhs>;                           \(\backslash\)}}
\DoxyCodeLine{326 \textcolor{preprocessor}{    constexpr bool check\_rhs\_hint =                                            \(\backslash\)}}
\DoxyCodeLine{327 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_volatile\_v<T\_RhsNoQ> ||                         \(\backslash\)}}
\DoxyCodeLine{328 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_RhsNoQ>;                       \(\backslash\)}}
\DoxyCodeLine{329 \textcolor{preprocessor}{    constexpr bool check\_lhs\_hint =                                            \(\backslash\)}}
\DoxyCodeLine{330 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_volatile\_v<T\_Wrap<T, T\_Sbx>>;                   \(\backslash\)}}
\DoxyCodeLine{331 \textcolor{preprocessor}{    constexpr bool is\_hint = check\_lhs\_hint || check\_rhs\_hint;                 \(\backslash\)}}
\DoxyCodeLine{332 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{    constexpr bool is\_unwrapped =                                              \(\backslash\)}}
\DoxyCodeLine{334 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_v<T\_Wrap<T, T\_Sbx>> \&\&                          \(\backslash\)}}
\DoxyCodeLine{335 \textcolor{preprocessor}{      std::is\_null\_pointer\_v<T\_RhsNoQ>;                                        \(\backslash\)}}
\DoxyCodeLine{336 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{337 \textcolor{preprocessor}{    }\textcolor{comment}{/* Sanity check -\/ can't be a hint and unwrapped */}\textcolor{preprocessor}{                         \(\backslash\)}}
\DoxyCodeLine{338 \textcolor{preprocessor}{    static\_assert(is\_hint ? !is\_unwrapped : true,                              \(\backslash\)}}
\DoxyCodeLine{339 \textcolor{preprocessor}{                  "{}Internal error: Could not deduce type for comparison. "{}}     \(\backslash\)}
\DoxyCodeLine{340                   "{}Please file a bug."{});                                       \(\backslash\)}
\DoxyCodeLine{341                                                                                \(\backslash\)}
\DoxyCodeLine{342     if constexpr (!permit\_pointers \&\& std::is\_pointer\_v<T>) \{                  \(\backslash\)}
\DoxyCodeLine{343       rlbox\_detail\_static\_fail\_because(                                        \(\backslash\)}
\DoxyCodeLine{344         std::is\_pointer\_v<T>,                                                  \(\backslash\)}
\DoxyCodeLine{345         "{}Only == and != comparisons are allowed for pointers"{});                \(\backslash\)}
\DoxyCodeLine{346     \}                                                                          \(\backslash\)}
\DoxyCodeLine{347                                                                                \(\backslash\)}
\DoxyCodeLine{348     bool ret = (impl().get\_raw\_value() opSymbol detail::unwrap\_value(rhs));    \(\backslash\)}
\DoxyCodeLine{349                                                                                \(\backslash\)}
\DoxyCodeLine{350     if constexpr (is\_hint) \{                                                   \(\backslash\)}
\DoxyCodeLine{351       return tainted\_boolean\_hint(ret);                                        \(\backslash\)}
\DoxyCodeLine{352     \} else if constexpr (is\_unwrapped) \{                                       \(\backslash\)}
\DoxyCodeLine{353       return ret;                                                              \(\backslash\)}
\DoxyCodeLine{354     \} else \{                                                                   \(\backslash\)}
\DoxyCodeLine{355       return tainted<bool, T\_Sbx>(ret);                                        \(\backslash\)}
\DoxyCodeLine{356     \}                                                                          \(\backslash\)}
\DoxyCodeLine{357   \}                                                                            \(\backslash\)}
\DoxyCodeLine{358   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{359 }
\DoxyCodeLine{360   CompareOp(==, \textcolor{keyword}{true} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{361   CompareOp(!=, \textcolor{keyword}{true} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{362   CompareOp(<, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{363   CompareOp(<=, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{364   CompareOp(>, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{365   CompareOp(>=, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{preprocessor}{\#undef CompareOp}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 \textcolor{keyword}{private}:}
\DoxyCodeLine{370   \textcolor{keyword}{using} T\_OpSubscriptArrRet = std::conditional\_t<}
\DoxyCodeLine{371     std::is\_pointer\_v<T>,}
\DoxyCodeLine{372     tainted\_volatile<detail::dereference\_result\_t<T>, T\_Sbx>, \textcolor{comment}{// is\_pointer}}
\DoxyCodeLine{373     T\_Wrap<detail::dereference\_result\_t<T>, T\_Sbx>            \textcolor{comment}{// is\_array}}
\DoxyCodeLine{374     >;}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{keyword}{public}:}
\DoxyCodeLine{377   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{378   \textcolor{keyword}{inline} \textcolor{keyword}{const} T\_OpSubscriptArrRet\& operator[](T\_Rhs\&\& rhs)\textcolor{keyword}{ const}}
\DoxyCodeLine{379 \textcolor{keyword}{  }\{}
\DoxyCodeLine{380     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T> || detail::is\_c\_or\_std\_array\_v<T>,}
\DoxyCodeLine{381                   \textcolor{stringliteral}{"{}Operator [] supports pointers and arrays only"{}});}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{keyword}{auto} raw\_rhs = detail::unwrap\_value(rhs);}
\DoxyCodeLine{384     \textcolor{keyword}{static\_assert}(std::is\_integral\_v<\textcolor{keyword}{decltype}(raw\_rhs)>,}
\DoxyCodeLine{385                   \textcolor{stringliteral}{"{}Can only index with numeric types"{}});}
\DoxyCodeLine{386 }
\DoxyCodeLine{387     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<T>) \{}
\DoxyCodeLine{388       \textcolor{keyword}{auto} ptr = this-\/>impl().get\_raw\_value();}
\DoxyCodeLine{389 }
\DoxyCodeLine{390       \textcolor{comment}{// increment the target by size of the data structure}}
\DoxyCodeLine{391       \textcolor{keyword}{auto} target =}
\DoxyCodeLine{392         \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(ptr) + raw\_rhs * \textcolor{keyword}{sizeof}(*this-\/>impl());}
\DoxyCodeLine{393       \textcolor{keyword}{auto} no\_overflow = \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox_a3257ffc0e7eb6022c05a049b8b36271f}{rlbox\_sandbox<T\_Sbx>::is\_in\_same\_sandbox}}(}
\DoxyCodeLine{394         ptr, \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(target));}
\DoxyCodeLine{395       detail::dynamic\_check(}
\DoxyCodeLine{396         no\_overflow,}
\DoxyCodeLine{397         \textcolor{stringliteral}{"{}Pointer arithmetic overflowed a pointer beyond sandbox memory"{}});}
\DoxyCodeLine{398 }
\DoxyCodeLine{399       \textcolor{keyword}{auto} target\_wrap = tainted<const T, T\_Sbx>::internal\_factory(}
\DoxyCodeLine{400         \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T\textcolor{keyword}{>}(target));}
\DoxyCodeLine{401       \textcolor{keywordflow}{return} *target\_wrap;}
\DoxyCodeLine{402     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{403       \textcolor{keyword}{using} T\_Rhs\_Unsigned = std::make\_unsigned\_t<\textcolor{keyword}{decltype}(raw\_rhs)>;}
\DoxyCodeLine{404       detail::dynamic\_check(}
\DoxyCodeLine{405         raw\_rhs >= 0 \&\& \textcolor{keyword}{static\_cast<}T\_Rhs\_Unsigned\textcolor{keyword}{>}(raw\_rhs) <}
\DoxyCodeLine{406                           std::extent\_v<detail::std\_array\_to\_c\_arr\_t<T>, 0>,}
\DoxyCodeLine{407         \textcolor{stringliteral}{"{}Static array indexing overflow"{}});}
\DoxyCodeLine{408 }
\DoxyCodeLine{409       \textcolor{keyword}{const} \textcolor{keywordtype}{void}* target\_ptr;}
\DoxyCodeLine{410       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::rlbox\_is\_tainted\_v<T\_Wrap<T, T\_Sbx>>) \{}
\DoxyCodeLine{411         \textcolor{keyword}{auto}\& data\_ref = impl().get\_raw\_value\_ref();}
\DoxyCodeLine{412         target\_ptr = \&(data\_ref[raw\_rhs]);}
\DoxyCodeLine{413       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{414         \textcolor{keyword}{auto}\& data\_ref = impl().get\_sandbox\_value\_ref();}
\DoxyCodeLine{415         \textcolor{keyword}{auto} target\_ptr\_vol = \&(data\_ref[raw\_rhs]);}
\DoxyCodeLine{416         \textcolor{comment}{// target\_ptr is a volatile... remove this.}}
\DoxyCodeLine{417         \textcolor{comment}{// Safe as we will return a tainted\_volatile if this is the case}}
\DoxyCodeLine{418         target\_ptr = detail::remove\_volatile\_from\_ptr\_cast(target\_ptr\_vol);}
\DoxyCodeLine{419       \}}
\DoxyCodeLine{420 }
\DoxyCodeLine{421       \textcolor{keyword}{using} T\_Target = \textcolor{keyword}{const} T\_Wrap<detail::dereference\_result\_t<T>, T\_Sbx>;}
\DoxyCodeLine{422       \textcolor{keyword}{auto} wrapped\_target\_ptr = \textcolor{keyword}{reinterpret\_cast<}T\_Target*\textcolor{keyword}{>}(target\_ptr);}
\DoxyCodeLine{423       \textcolor{keywordflow}{return} *wrapped\_target\_ptr;}
\DoxyCodeLine{424     \}}
\DoxyCodeLine{425   \}}
\DoxyCodeLine{426 }
\DoxyCodeLine{427   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{428   \textcolor{keyword}{inline} T\_OpSubscriptArrRet\& operator[](T\_Rhs\&\& rhs)}
\DoxyCodeLine{429   \{}
\DoxyCodeLine{430     rlbox\_detail\_forward\_to\_const\_a(\textcolor{keyword}{operator}[], T\_OpSubscriptArrRet\&, rhs);}
\DoxyCodeLine{431   \}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 \textcolor{keyword}{private}:}
\DoxyCodeLine{434   \textcolor{keyword}{using} T\_OpDerefRet = tainted\_volatile<std::remove\_pointer\_t<T>, T\_Sbx>;}
\DoxyCodeLine{435 }
\DoxyCodeLine{436 \textcolor{keyword}{public}:}
\DoxyCodeLine{437   \textcolor{keyword}{inline} T\_OpDerefRet\& operator*()\textcolor{keyword}{ const}}
\DoxyCodeLine{438 \textcolor{keyword}{  }\{}
\DoxyCodeLine{439     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>, \textcolor{stringliteral}{"{}Operator * only allowed on pointers"{}});}
\DoxyCodeLine{440     \textcolor{keyword}{auto} ret\_ptr\_const =}
\DoxyCodeLine{441       \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T\_OpDerefRet*\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{442     \textcolor{comment}{// Safe -\/ If T\_OpDerefRet is not a const ptr, this is trivially safe}}
\DoxyCodeLine{443     \textcolor{comment}{//        If T\_OpDerefRet is a const ptr, then the const is captured}}
\DoxyCodeLine{444     \textcolor{comment}{//        inside the wrapper}}
\DoxyCodeLine{445     \textcolor{keyword}{auto} ret\_ptr = \textcolor{keyword}{const\_cast<}T\_OpDerefRet*\textcolor{keyword}{>}(ret\_ptr\_const);}
\DoxyCodeLine{446     \textcolor{keywordflow}{return} *ret\_ptr;}
\DoxyCodeLine{447   \}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449   \textcolor{keyword}{inline} T\_OpDerefRet\& operator*()}
\DoxyCodeLine{450   \{}
\DoxyCodeLine{451     rlbox\_detail\_forward\_to\_const(\textcolor{keyword}{operator}*, T\_OpDerefRet\&);}
\DoxyCodeLine{452   \}}
\DoxyCodeLine{453 }
\DoxyCodeLine{454   \textcolor{comment}{// We need to implement the -\/> operator even if T is not a struct}}
\DoxyCodeLine{455   \textcolor{comment}{// So that we can support code patterns such as the below}}
\DoxyCodeLine{456   \textcolor{comment}{// tainted<T*> a;}}
\DoxyCodeLine{457   \textcolor{comment}{// a-\/>UNSAFE\_unverified();}}
\DoxyCodeLine{458   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator-\/>()\textcolor{keyword}{ const}}
\DoxyCodeLine{459 \textcolor{keyword}{  }\{}
\DoxyCodeLine{460     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{461                   \textcolor{stringliteral}{"{}Operator -\/> only supported for pointer types"{}});}
\DoxyCodeLine{462     \textcolor{keyword}{auto} ret = impl().get\_raw\_value();}
\DoxyCodeLine{463     \textcolor{keyword}{using} T\_Ret = std::remove\_pointer\_t<T>;}
\DoxyCodeLine{464     \textcolor{keyword}{using} T\_RetWrap = \textcolor{keyword}{const} tainted\_volatile<T\_Ret, T\_Sbx>;}
\DoxyCodeLine{465     \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}T\_RetWrap*\textcolor{keyword}{>}(ret);}
\DoxyCodeLine{466   \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator-\/>()}
\DoxyCodeLine{469   \{}
\DoxyCodeLine{470     \textcolor{keyword}{using} T\_Ret = tainted\_volatile<std::remove\_pointer\_t<T>, T\_Sbx>*;}
\DoxyCodeLine{471     rlbox\_detail\_forward\_to\_const(operator-\/>, T\_Ret);}
\DoxyCodeLine{472   \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator!()}
\DoxyCodeLine{475   \{}
\DoxyCodeLine{476     if\_constexpr\_named(cond1, std::is\_pointer\_v<T>)}
\DoxyCodeLine{477     \{}
\DoxyCodeLine{478       \textcolor{keywordflow}{return} impl() == \textcolor{keyword}{nullptr};}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480     \textcolor{keywordflow}{else} if\_constexpr\_named(cond2, std::is\_same\_v<std::remove\_cv\_t<T>, \textcolor{keywordtype}{bool}>)}
\DoxyCodeLine{481     \{}
\DoxyCodeLine{482       \textcolor{keywordflow}{return} impl() == \textcolor{keyword}{false};}
\DoxyCodeLine{483     \}}
\DoxyCodeLine{484     \textcolor{keywordflow}{else}}
\DoxyCodeLine{485     \{}
\DoxyCodeLine{486       \textcolor{keyword}{auto} unknownCase = !(cond1 || cond2);}
\DoxyCodeLine{487       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{488         unknownCase,}
\DoxyCodeLine{489         \textcolor{stringliteral}{"{}Operator ! only permitted for pointer or boolean types. For other"{}}}
\DoxyCodeLine{490         \textcolor{stringliteral}{"{}types, unwrap the tainted value with the copy\_and\_verify API and then"{}}}
\DoxyCodeLine{491         \textcolor{stringliteral}{"{}use operator !"{}});}
\DoxyCodeLine{492     \}}
\DoxyCodeLine{493   \}}
\DoxyCodeLine{494 }
\DoxyCodeLine{502   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{503   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}{copy\_and\_verify}}(T\_Func verifier)\textcolor{keyword}{ const}}
\DoxyCodeLine{504 \textcolor{keyword}{  }\{}
\DoxyCodeLine{505     \textcolor{keyword}{using} T\_Deref = std::remove\_cv\_t<std::remove\_pointer\_t<T>>;}
\DoxyCodeLine{506 }
\DoxyCodeLine{507     if\_constexpr\_named(cond1, detail::is\_fundamental\_or\_enum\_v<T>)}
\DoxyCodeLine{508     \{}
\DoxyCodeLine{509       \textcolor{keyword}{auto} val = impl().get\_raw\_value();}
\DoxyCodeLine{510       \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{511     \}}
\DoxyCodeLine{512     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{513       cond2, detail::is\_one\_level\_ptr\_v<T> \&\& !std::is\_class\_v<T\_Deref>)}
\DoxyCodeLine{514     \{}
\DoxyCodeLine{515       \textcolor{comment}{// Some paths don't use the verifier}}
\DoxyCodeLine{516       RLBOX\_UNUSED(verifier);}
\DoxyCodeLine{517 }
\DoxyCodeLine{518       if\_constexpr\_named(subcond1, std::is\_void\_v<T\_Deref>)}
\DoxyCodeLine{519       \{}
\DoxyCodeLine{520         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{521           subcond1,}
\DoxyCodeLine{522           \textcolor{stringliteral}{"{}copy\_and\_verify not recommended for void* as it could lead to some "{}}}
\DoxyCodeLine{523           \textcolor{stringliteral}{"{}anti-\/patterns in verifiers. Cast it to a different tainted pointer "{}}}
\DoxyCodeLine{524           \textcolor{stringliteral}{"{}with sandbox\_reinterpret\_cast and then call copy\_and\_verify. "{}}}
\DoxyCodeLine{525           \textcolor{stringliteral}{"{}Alternately, you can use the UNSAFE\_unverified API to do this "{}}}
\DoxyCodeLine{526           \textcolor{stringliteral}{"{}without casting."{}});}
\DoxyCodeLine{527         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{528       \}}
\DoxyCodeLine{529       \textcolor{comment}{// Test with detail::is\_func\_ptr\_v to check for member funcs also}}
\DoxyCodeLine{530       \textcolor{keywordflow}{else} if\_constexpr\_named(subcond2, detail::is\_func\_ptr\_v<T>)}
\DoxyCodeLine{531       \{}
\DoxyCodeLine{532         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{533           subcond2,}
\DoxyCodeLine{534           \textcolor{stringliteral}{"{}copy\_and\_verify cannot be applied to function pointers as this "{}}}
\DoxyCodeLine{535           \textcolor{stringliteral}{"{}makes a deep copy. This is not possible for function pointers. "{}}}
\DoxyCodeLine{536           \textcolor{stringliteral}{"{}Consider copy\_and\_verify\_address instead."{}});}
\DoxyCodeLine{537         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{538       \}}
\DoxyCodeLine{539       \textcolor{keywordflow}{else}}
\DoxyCodeLine{540       \{}
\DoxyCodeLine{541         \textcolor{keyword}{auto} val = impl().get\_raw\_value();}
\DoxyCodeLine{542         \textcolor{keywordflow}{if} (val == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{543           \textcolor{keywordflow}{return} verifier(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{544         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{545           \textcolor{comment}{// Important to assign to a local variable (i.e. make a copy)}}
\DoxyCodeLine{546           \textcolor{comment}{// Else, for tainted\_volatile, this will allow a}}
\DoxyCodeLine{547           \textcolor{comment}{// time-\/of-\/check-\/time-\/of-\/use attack}}
\DoxyCodeLine{548           \textcolor{keyword}{auto} val\_copy = std::make\_unique<T\_Deref>();}
\DoxyCodeLine{549           *val\_copy = *val;}
\DoxyCodeLine{550           \textcolor{keywordflow}{return} verifier(std::move(val\_copy));}
\DoxyCodeLine{551         \}}
\DoxyCodeLine{552       \}}
\DoxyCodeLine{553     \}}
\DoxyCodeLine{554     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{555       cond3, detail::is\_one\_level\_ptr\_v<T> \&\& std::is\_class\_v<T\_Deref>)}
\DoxyCodeLine{556     \{}
\DoxyCodeLine{557       \textcolor{keyword}{auto} val\_copy = std::make\_unique<tainted<T\_Deref, T\_Sbx>>(*impl());}
\DoxyCodeLine{558       \textcolor{keywordflow}{return} verifier(std::move(val\_copy));}
\DoxyCodeLine{559     \}}
\DoxyCodeLine{560     \textcolor{keywordflow}{else} if\_constexpr\_named(cond4, std::is\_array\_v<T>)}
\DoxyCodeLine{561     \{}
\DoxyCodeLine{562       \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{563         detail::is\_fundamental\_or\_enum\_v<std::remove\_all\_extents\_t<T>>,}
\DoxyCodeLine{564         \textcolor{stringliteral}{"{}copy\_and\_verify on arrays is only safe for fundamental or enum types. "{}}}
\DoxyCodeLine{565         \textcolor{stringliteral}{"{}For arrays of other types, apply copy\_and\_verify on each element "{}}}
\DoxyCodeLine{566         \textcolor{stringliteral}{"{}individually -\/-\/-\/ a[i].copy\_and\_verify(...)"{}});}
\DoxyCodeLine{567 }
\DoxyCodeLine{568       \textcolor{keyword}{auto} copy = impl().get\_raw\_value();}
\DoxyCodeLine{569       \textcolor{keywordflow}{return} verifier(copy);}
\DoxyCodeLine{570     \}}
\DoxyCodeLine{571     \textcolor{keywordflow}{else}}
\DoxyCodeLine{572     \{}
\DoxyCodeLine{573       \textcolor{keyword}{auto} unknownCase = !(cond1 || cond2 || cond3 || cond4);}
\DoxyCodeLine{574       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{575         unknownCase,}
\DoxyCodeLine{576         \textcolor{stringliteral}{"{}copy\_and\_verify not supported for this type as it may be unsafe"{}});}
\DoxyCodeLine{577     \}}
\DoxyCodeLine{578   \}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{keyword}{private}:}
\DoxyCodeLine{581   \textcolor{keyword}{using} T\_CopyAndVerifyRangeEl =}
\DoxyCodeLine{582     detail::valid\_array\_el\_t<std::remove\_cv\_t<std::remove\_pointer\_t<T>>>;}
\DoxyCodeLine{583 }
\DoxyCodeLine{584   \textcolor{comment}{// Template needed to ensure that function isn't instantiated for unsupported}}
\DoxyCodeLine{585   \textcolor{comment}{// types like function pointers which causes compile errors...}}
\DoxyCodeLine{586   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T>}
\DoxyCodeLine{587   \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{void}* verify\_range\_helper(std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{588 \textcolor{keyword}{  }\{}
\DoxyCodeLine{589     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{590     \textcolor{keyword}{static\_assert}(detail::is\_fundamental\_or\_enum\_v<T\_CopyAndVerifyRangeEl>);}
\DoxyCodeLine{591 }
\DoxyCodeLine{592     detail::dynamic\_check(}
\DoxyCodeLine{593       count != 0,}
\DoxyCodeLine{594       \textcolor{stringliteral}{"{}Called copy\_and\_verify\_range/copy\_and\_verify\_string with count 0"{}});}
\DoxyCodeLine{595 }
\DoxyCodeLine{596     \textcolor{keyword}{auto} start = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{597     \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{598       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{599     \}}
\DoxyCodeLine{600 }
\DoxyCodeLine{601     detail::check\_range\_doesnt\_cross\_app\_sbx\_boundary<T\_Sbx>(}
\DoxyCodeLine{602       start, count * \textcolor{keyword}{sizeof}(T\_CopyAndVerifyRangeEl));}
\DoxyCodeLine{603 }
\DoxyCodeLine{604     \textcolor{keywordflow}{return} start;}
\DoxyCodeLine{605   \}}
\DoxyCodeLine{606 }
\DoxyCodeLine{607   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T>}
\DoxyCodeLine{608   \textcolor{keyword}{inline} std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> copy\_and\_verify\_range\_helper(}
\DoxyCodeLine{609     std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{610 \textcolor{keyword}{  }\{}
\DoxyCodeLine{611     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* start = verify\_range\_helper(count);}
\DoxyCodeLine{612     \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{613       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{614     \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616     \textcolor{keyword}{auto} target = std::make\_unique<T\_CopyAndVerifyRangeEl[]>(count);}
\DoxyCodeLine{617 }
\DoxyCodeLine{618     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < count; i++) \{}
\DoxyCodeLine{619       \textcolor{keyword}{auto} p\_src\_i\_tainted = \&(impl()[i]);}
\DoxyCodeLine{620       \textcolor{keyword}{auto} p\_src\_i = p\_src\_i\_tainted.get\_raw\_value();}
\DoxyCodeLine{621       detail::convert\_type\_fundamental\_or\_array(target[i], *p\_src\_i);}
\DoxyCodeLine{622     \}}
\DoxyCodeLine{623 }
\DoxyCodeLine{624     \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{625   \}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 \textcolor{keyword}{public}:}
\DoxyCodeLine{637   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{638   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a76e49089d448ba0cfa7ef6d7c1e2d288}{copy\_and\_verify\_range}}(T\_Func verifier, std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{639 \textcolor{keyword}{  }\{}
\DoxyCodeLine{640     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{641                   \textcolor{stringliteral}{"{}Can only call copy\_and\_verify\_range on pointers"{}});}
\DoxyCodeLine{642 }
\DoxyCodeLine{643     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{644       detail::is\_fundamental\_or\_enum\_v<T\_CopyAndVerifyRangeEl>,}
\DoxyCodeLine{645       \textcolor{stringliteral}{"{}copy\_and\_verify\_range is only safe for ranges of "{}}}
\DoxyCodeLine{646       \textcolor{stringliteral}{"{}fundamental or enum types. For other types, call "{}}}
\DoxyCodeLine{647       \textcolor{stringliteral}{"{}copy\_and\_verify on each element -\/-\/-\/ a[i].copy\_and\_verify(...)"{}});}
\DoxyCodeLine{648 }
\DoxyCodeLine{649     std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> target =}
\DoxyCodeLine{650       copy\_and\_verify\_range\_helper(count);}
\DoxyCodeLine{651     \textcolor{keywordflow}{return} verifier(std::move(target));}
\DoxyCodeLine{652   \}}
\DoxyCodeLine{653 }
\DoxyCodeLine{662   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{663   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_aa377cc4d0ea6768ada5032234ac89aab}{copy\_and\_verify\_string}}(T\_Func verifier)\textcolor{keyword}{ const}}
\DoxyCodeLine{664 \textcolor{keyword}{  }\{}
\DoxyCodeLine{665     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{666                   \textcolor{stringliteral}{"{}Can only call copy\_and\_verify\_string on pointers"{}});}
\DoxyCodeLine{667 }
\DoxyCodeLine{668     \textcolor{keyword}{static\_assert}(std::is\_same\_v<char, T\_CopyAndVerifyRangeEl>,}
\DoxyCodeLine{669                   \textcolor{stringliteral}{"{}copy\_and\_verify\_string only allows char*"{}});}
\DoxyCodeLine{670 }
\DoxyCodeLine{671     \textcolor{keyword}{using} T\_VerifParam = detail::func\_first\_arg\_t<T\_Func>;}
\DoxyCodeLine{672 }
\DoxyCodeLine{673     \textcolor{keyword}{auto} start = impl().get\_raw\_value();}
\DoxyCodeLine{674     if\_constexpr\_named(}
\DoxyCodeLine{675       cond1,}
\DoxyCodeLine{676       std::is\_same\_v<T\_VerifParam, std::unique\_ptr<\textcolor{keywordtype}{char}[]>> ||}
\DoxyCodeLine{677         std::is\_same\_v<T\_VerifParam, std::unique\_ptr<\textcolor{keyword}{const} \textcolor{keywordtype}{char}[]>>)}
\DoxyCodeLine{678     \{}
\DoxyCodeLine{679       \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{680         \textcolor{keywordflow}{return} verifier(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{681       \}}
\DoxyCodeLine{682 }
\DoxyCodeLine{683       \textcolor{comment}{// it is safe to run strlen on a tainted<string> as worst case, the string}}
\DoxyCodeLine{684       \textcolor{comment}{// does not have a null and we try to copy all the memory out of the}}
\DoxyCodeLine{685       \textcolor{comment}{// sandbox however, copy\_and\_verify\_range ensures that we never copy}}
\DoxyCodeLine{686       \textcolor{comment}{// memory outsider the range}}
\DoxyCodeLine{687       \textcolor{keyword}{auto} str\_len = std::strlen(start) + 1;}
\DoxyCodeLine{688       std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> target =}
\DoxyCodeLine{689         copy\_and\_verify\_range\_helper(str\_len);}
\DoxyCodeLine{690 }
\DoxyCodeLine{691       \textcolor{comment}{// ensure the string has a trailing null}}
\DoxyCodeLine{692       target[str\_len -\/ 1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{693 }
\DoxyCodeLine{694       \textcolor{keywordflow}{return} verifier(std::move(target));}
\DoxyCodeLine{695     \}}
\DoxyCodeLine{696     \textcolor{keywordflow}{else} if\_constexpr\_named(cond2, std::is\_same\_v<T\_VerifParam, std::string>)}
\DoxyCodeLine{697     \{}
\DoxyCodeLine{698       \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{699         std::string param = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{700         \textcolor{keywordflow}{return} verifier(param);}
\DoxyCodeLine{701       \}}
\DoxyCodeLine{702 }
\DoxyCodeLine{703       \textcolor{comment}{// it is safe to run strlen on a tainted<string> as worst case, the string}}
\DoxyCodeLine{704       \textcolor{comment}{// does not have a null and we try to copy all the memory out of the}}
\DoxyCodeLine{705       \textcolor{comment}{// sandbox however, copy\_and\_verify\_range ensures that we never copy}}
\DoxyCodeLine{706       \textcolor{comment}{// memory outsider the range}}
\DoxyCodeLine{707       \textcolor{keyword}{auto} str\_len = std::strlen(start) + 1;}
\DoxyCodeLine{708 }
\DoxyCodeLine{709       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* checked\_start = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)verify\_range\_helper(str\_len);}
\DoxyCodeLine{710       \textcolor{keywordflow}{if} (checked\_start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{711         std::string param = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{712         \textcolor{keywordflow}{return} verifier(param);}
\DoxyCodeLine{713       \}}
\DoxyCodeLine{714 }
\DoxyCodeLine{715       std::string copy(checked\_start, str\_len -\/ 1);}
\DoxyCodeLine{716       \textcolor{keywordflow}{return} verifier(std::move(copy));}
\DoxyCodeLine{717     \}}
\DoxyCodeLine{718     \textcolor{keywordflow}{else}}
\DoxyCodeLine{719     \{}
\DoxyCodeLine{720       \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} unknownCase = !(cond1 || cond2);}
\DoxyCodeLine{721       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{722         unknownCase,}
\DoxyCodeLine{723         \textcolor{stringliteral}{"{}copy\_and\_verify\_string verifier parameter should either be "{}}}
\DoxyCodeLine{724         \textcolor{stringliteral}{"{}unique\_ptr<char[]>, unique\_ptr<const char[]> or std::string"{}});}
\DoxyCodeLine{725     \}}
\DoxyCodeLine{726   \}}
\DoxyCodeLine{727 }
\DoxyCodeLine{739   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{740   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ad34419b3444d0bf37e25ecf7d37fbe0b}{copy\_and\_verify\_address}}(T\_Func verifier)}
\DoxyCodeLine{741   \{}
\DoxyCodeLine{742     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{743                   \textcolor{stringliteral}{"{}copy\_and\_verify\_address must be used on pointers"{}});}
\DoxyCodeLine{744     \textcolor{keyword}{auto} val = \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{745     \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{746   \}}
\DoxyCodeLine{747 }
\DoxyCodeLine{762   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{763   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a4f739a0994af23036cce2d06b10953ee}{copy\_and\_verify\_buffer\_address}}(T\_Func verifier, std::size\_t size)}
\DoxyCodeLine{764   \{}
\DoxyCodeLine{765     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{766                   \textcolor{stringliteral}{"{}copy\_and\_verify\_address must be used on pointers"{}});}
\DoxyCodeLine{767     \textcolor{keyword}{auto} val = \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(verify\_range\_helper(size));}
\DoxyCodeLine{768     \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{769   \}}
\DoxyCodeLine{770 \};}
\DoxyCodeLine{771 }
\DoxyCodeLine{772 \textcolor{preprocessor}{\#define BinaryOpWrappedRhs(opSymbol)                                           \(\backslash\)}}
\DoxyCodeLine{773 \textcolor{preprocessor}{  template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}}
\DoxyCodeLine{774 \textcolor{preprocessor}{           typename T,                                                         \(\backslash\)}}
\DoxyCodeLine{775 \textcolor{preprocessor}{           typename T\_Sbx,                                                     \(\backslash\)}}
\DoxyCodeLine{776 \textcolor{preprocessor}{           typename T\_Lhs,                                                     \(\backslash\)}}
\DoxyCodeLine{777 \textcolor{preprocessor}{           RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{                           !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}}
\DoxyCodeLine{779 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(                                     \(\backslash\)}}
\DoxyCodeLine{780 \textcolor{preprocessor}{    const T\_Lhs\& lhs, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\& rhs)          \(\backslash\)}}
\DoxyCodeLine{781 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{782 \textcolor{preprocessor}{    }\textcolor{comment}{/* Handles the case for "{}3 + tainted"{}, where + is a binary op */}\textcolor{preprocessor}{           \(\backslash\)}}
\DoxyCodeLine{783 \textcolor{preprocessor}{    }\textcolor{comment}{/* Technically pointer arithmetic can be performed as 3 + tainted\_ptr */}\textcolor{preprocessor}{   \(\backslash\)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{    }\textcolor{comment}{/* as well. However, this is unusual and to keep the code simple we do */}\textcolor{preprocessor}{  \(\backslash\)}}
\DoxyCodeLine{785 \textcolor{preprocessor}{    }\textcolor{comment}{/* not support this. */}\textcolor{preprocessor}{                                                    \(\backslash\)}}
\DoxyCodeLine{786 \textcolor{preprocessor}{    static\_assert(                                                             \(\backslash\)}}
\DoxyCodeLine{787 \textcolor{preprocessor}{      std::is\_arithmetic\_v<T\_Lhs>,                                             \(\backslash\)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{      "{}Binary expressions between an non tainted type and tainted"{}}             \(\backslash\)}
\DoxyCodeLine{789       "{}type is only permitted if the first value is the tainted type. Try "{}    \(\backslash\)}
\DoxyCodeLine{790       "{}changing the order of the binary expression accordingly"{});              \(\backslash\)}
\DoxyCodeLine{791     auto ret = tainted<T\_Lhs, T\_Sbx>(lhs) opSymbol rhs.impl();                 \(\backslash\)}
\DoxyCodeLine{792     return ret;                                                                \(\backslash\)}
\DoxyCodeLine{793   \}                                                                            \(\backslash\)}
\DoxyCodeLine{794   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{795 }
\DoxyCodeLine{796 BinaryOpWrappedRhs(+);}
\DoxyCodeLine{797 BinaryOpWrappedRhs(-\/);}
\DoxyCodeLine{798 BinaryOpWrappedRhs(*);}
\DoxyCodeLine{799 BinaryOpWrappedRhs(/);}
\DoxyCodeLine{800 BinaryOpWrappedRhs(\%);}
\DoxyCodeLine{801 BinaryOpWrappedRhs(\string^);}
\DoxyCodeLine{802 BinaryOpWrappedRhs(\&);}
\DoxyCodeLine{803 BinaryOpWrappedRhs(|);}
\DoxyCodeLine{804 BinaryOpWrappedRhs(<<);}
\DoxyCodeLine{805 BinaryOpWrappedRhs(>>);}
\DoxyCodeLine{806 BinaryOpWrappedRhs(==);}
\DoxyCodeLine{807 BinaryOpWrappedRhs(!=);}
\DoxyCodeLine{808 BinaryOpWrappedRhs(<);}
\DoxyCodeLine{809 BinaryOpWrappedRhs(<=);}
\DoxyCodeLine{810 BinaryOpWrappedRhs(>);}
\DoxyCodeLine{811 BinaryOpWrappedRhs(>=);}
\DoxyCodeLine{812 \textcolor{preprocessor}{\#undef BinaryOpWrappedRhs}}
\DoxyCodeLine{813 }
\DoxyCodeLine{814 \textcolor{preprocessor}{\#define BooleanBinaryOpWrappedRhs(opSymbol)                                    \(\backslash\)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{  template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{           typename T,                                                         \(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{           typename T\_Sbx,                                                     \(\backslash\)}}
\DoxyCodeLine{818 \textcolor{preprocessor}{           typename T\_Lhs,                                                     \(\backslash\)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{           RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}}
\DoxyCodeLine{820 \textcolor{preprocessor}{                           !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}}
\DoxyCodeLine{821 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(                                     \(\backslash\)}}
\DoxyCodeLine{822 \textcolor{preprocessor}{    const T\_Lhs\& lhs, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\& rhs)          \(\backslash\)}}
\DoxyCodeLine{823 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{824 \textcolor{preprocessor}{    static\_assert(                                                             \(\backslash\)}}
\DoxyCodeLine{825 \textcolor{preprocessor}{      std::is\_arithmetic\_v<T\_Lhs>,                                             \(\backslash\)}}
\DoxyCodeLine{826 \textcolor{preprocessor}{      "{}Binary expressions between an non tainted type and tainted"{}}             \(\backslash\)}
\DoxyCodeLine{827       "{}type is only permitted if the first value is the tainted type. Try "{}    \(\backslash\)}
\DoxyCodeLine{828       "{}changing the order of the binary expression accordingly"{});              \(\backslash\)}
\DoxyCodeLine{829     auto ret = tainted<T\_Lhs, T\_Sbx>(lhs) opSymbol rhs.impl();                 \(\backslash\)}
\DoxyCodeLine{830     return ret;                                                                \(\backslash\)}
\DoxyCodeLine{831   \}                                                                            \(\backslash\)}
\DoxyCodeLine{832                                                                                \(\backslash\)}
\DoxyCodeLine{833   template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}
\DoxyCodeLine{834            typename T,                                                         \(\backslash\)}
\DoxyCodeLine{835            typename T\_Sbx,                                                     \(\backslash\)}
\DoxyCodeLine{836            typename T\_Lhs,                                                     \(\backslash\)}
\DoxyCodeLine{837            RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}
\DoxyCodeLine{838                            !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}
\DoxyCodeLine{839   inline constexpr auto operator opSymbol(                                     \(\backslash\)}
\DoxyCodeLine{840     const T\_Lhs\&, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\&\&)                 \(\backslash\)}
\DoxyCodeLine{841   \{                                                                            \(\backslash\)}
\DoxyCodeLine{842     rlbox\_detail\_static\_fail\_because(                                          \(\backslash\)}
\DoxyCodeLine{843       detail::true\_v<T\_Lhs>,                                                   \(\backslash\)}
\DoxyCodeLine{844       "{}C++ does not permit safe overloading of \&\& and || operations as this "{}  \(\backslash\)}
\DoxyCodeLine{845       "{}affects the short circuiting behaviour of these operations. RLBox "{}     \(\backslash\)}
\DoxyCodeLine{846       "{}does let you use \&\& and || with tainted in limited situations -\/ when "{}  \(\backslash\)}
\DoxyCodeLine{847       "{}all arguments starting from the second are local variables. It does "{}   \(\backslash\)}
\DoxyCodeLine{848       "{}not allow it if arguments starting from the second  are expressions.\(\backslash\)n"{} \(\backslash\)}
\DoxyCodeLine{849       "{}For example the following is not allowed\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{850       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{851       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{852       "{}auto r = a \&\& true \&\& sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}      \(\backslash\)}
\DoxyCodeLine{853       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{854       "{}However the following would be allowed\(\backslash\)n"{}                               \(\backslash\)}
\DoxyCodeLine{855       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{856       "{}auto b = true\(\backslash\)n"{}                                                        \(\backslash\)}
\DoxyCodeLine{857       "{}auto c = sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}                   \(\backslash\)}
\DoxyCodeLine{858       "{}auto r = a \&\& b \&\& c;\(\backslash\)n"{}                                                \(\backslash\)}
\DoxyCodeLine{859       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{860       "{}Note that these 2 programs are not identical. The first program may "{}   \(\backslash\)}
\DoxyCodeLine{861       "{}or may not call getBool, while second program always calls getBool"{});   \(\backslash\)}
\DoxyCodeLine{862     return tainted<bool, T\_Sbx>(false);                                        \(\backslash\)}
\DoxyCodeLine{863   \}                                                                            \(\backslash\)}
\DoxyCodeLine{864   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{865 }
\DoxyCodeLine{866 BooleanBinaryOpWrappedRhs(\&\&);}
\DoxyCodeLine{867 BooleanBinaryOpWrappedRhs(||);}
\DoxyCodeLine{868 \textcolor{preprocessor}{\#undef BooleanBinaryOpWrappedRhs}}
\DoxyCodeLine{869 }
\DoxyCodeLine{870 \textcolor{keyword}{namespace }tainted\_detail \{}
\DoxyCodeLine{871   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{872   \textcolor{keyword}{using} tainted\_repr\_t = detail::c\_to\_std\_array\_t<T>;}
\DoxyCodeLine{873 }
\DoxyCodeLine{874   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{875   \textcolor{keyword}{using} tainted\_vol\_repr\_t =}
\DoxyCodeLine{876     detail::c\_to\_std\_array\_t<std::add\_volatile\_t<\textcolor{keyword}{typename} rlbox\_sandbox<}
\DoxyCodeLine{877       T\_Sbx>::template convert\_to\_sandbox\_equivalent\_nonclass\_t<T>>>;}
\DoxyCodeLine{878 \}}
\DoxyCodeLine{879 }
\DoxyCodeLine{884 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{885 \textcolor{keyword}{class }tainted : \textcolor{keyword}{public} tainted\_base\_impl<tainted, T, T\_Sbx>}
\DoxyCodeLine{886 \{}
\DoxyCodeLine{887   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{888   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{889 }
\DoxyCodeLine{890   \textcolor{comment}{// Classes recieve their own specialization}}
\DoxyCodeLine{891   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{892     !std::is\_class\_v<T>,}
\DoxyCodeLine{893     \textcolor{stringliteral}{"{}Missing definition for class T. This error occurs for one "{}}}
\DoxyCodeLine{894     \textcolor{stringliteral}{"{}of 2 reasons.\(\backslash\)n"{}}}
\DoxyCodeLine{895     \textcolor{stringliteral}{"{}  1) Make sure you have include a call rlbox\_load\_structs\_from\_library "{}}}
\DoxyCodeLine{896     \textcolor{stringliteral}{"{}for this library with this class included.\(\backslash\)n"{}}}
\DoxyCodeLine{897     \textcolor{stringliteral}{"{}  2) Make sure you run (re-\/run) the struct-\/dump tool to list "{}}}
\DoxyCodeLine{898     \textcolor{stringliteral}{"{}all structs in use by your program.\(\backslash\)n"{}});}
\DoxyCodeLine{899 }
\DoxyCodeLine{900   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{901     detail::is\_basic\_type\_v<T> || std::is\_array\_v<T>,}
\DoxyCodeLine{902     \textcolor{stringliteral}{"{}Tainted types only support fundamental, enum, pointer, array and struct "{}}}
\DoxyCodeLine{903     \textcolor{stringliteral}{"{}types. Please file a bug if more support is needed."{}});}
\DoxyCodeLine{904 }
\DoxyCodeLine{905 \textcolor{keyword}{private}:}
\DoxyCodeLine{906   \textcolor{keyword}{using} T\_ClassBase = tainted\_base\_impl<tainted, T, T\_Sbx>;}
\DoxyCodeLine{907   \textcolor{keyword}{using} T\_AppType = tainted\_detail::tainted\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{908   \textcolor{keyword}{using} T\_SandboxedType = tainted\_detail::tainted\_vol\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{909   T\_AppType data;}
\DoxyCodeLine{910 }
\DoxyCodeLine{911   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_raw\_value\_ref() noexcept \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{912   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_raw\_value\_ref() const noexcept \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{913 }
\DoxyCodeLine{914   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value() const noexcept}
\DoxyCodeLine{915   \{}
\DoxyCodeLine{916     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{917   \}}
\DoxyCodeLine{918 }
\DoxyCodeLine{919   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{920     rlbox\_sandbox<T\_Sbx>\& sandbox)\textcolor{keyword}{ const}}
\DoxyCodeLine{921 \textcolor{keyword}{  }\{}
\DoxyCodeLine{922     std::remove\_cv\_t<T\_SandboxedType> ret;}
\DoxyCodeLine{923 }
\DoxyCodeLine{924     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{925     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{926                            adjust\_type\_direction::TO\_SANDBOX,}
\DoxyCodeLine{927                            adjust\_type\_context::SANDBOX>(}
\DoxyCodeLine{928       ret, data, \textcolor{keyword}{nullptr} \textcolor{comment}{/* example\_unsandboxed\_ptr */}, \&sandbox);}
\DoxyCodeLine{929     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{930   \};}
\DoxyCodeLine{931 }
\DoxyCodeLine{932   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value() noexcept}
\DoxyCodeLine{933   \{}
\DoxyCodeLine{934     rlbox\_detail\_forward\_to\_const(get\_raw\_value, std::remove\_cv\_t<T\_AppType>);}
\DoxyCodeLine{935   \}}
\DoxyCodeLine{936 }
\DoxyCodeLine{937   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{938     rlbox\_sandbox<T\_Sbx>\& sandbox)}
\DoxyCodeLine{939   \{}
\DoxyCodeLine{940     rlbox\_detail\_forward\_to\_const\_a(}
\DoxyCodeLine{941       get\_raw\_sandbox\_value, std::remove\_cv\_t<T\_SandboxedType>, sandbox);}
\DoxyCodeLine{942   \};}
\DoxyCodeLine{943 }
\DoxyCodeLine{944   \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{void}* find\_example\_pointer\_or\_null() const noexcept}
\DoxyCodeLine{945   \{}
\DoxyCodeLine{946     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_array\_v<T>) \{}
\DoxyCodeLine{947       \textcolor{keyword}{auto}\& data\_ref = get\_raw\_value\_ref();}
\DoxyCodeLine{948 }
\DoxyCodeLine{949       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < std::extent\_v<T>; i++) \{}
\DoxyCodeLine{950         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* ret = data[i].find\_example\_pointer\_or\_null();}
\DoxyCodeLine{951         \textcolor{keywordflow}{if} (ret != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{952           \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{953         \}}
\DoxyCodeLine{954       \}}
\DoxyCodeLine{955     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<T> \&\& !detail::is\_func\_ptr\_v<T>) \{}
\DoxyCodeLine{956       \textcolor{keyword}{auto} data = get\_raw\_value();}
\DoxyCodeLine{957       \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{958     \}}
\DoxyCodeLine{959     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{960   \}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962   \textcolor{comment}{// Initializing with a pointer is dangerous and permitted only internally}}
\DoxyCodeLine{963   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T, RLBOX\_ENABLE\_IF(std::is\_po\textcolor{keywordtype}{int}er\_v<T2>)>}
\DoxyCodeLine{964   tainted(T2 val, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \textcolor{comment}{/* internal\_tag */})}
\DoxyCodeLine{965     : data(val)}
\DoxyCodeLine{966   \{}
\DoxyCodeLine{967     \textcolor{comment}{// Sanity check}}
\DoxyCodeLine{968     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{969   \}}
\DoxyCodeLine{970 }
\DoxyCodeLine{971   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{972   \textcolor{keyword}{static} \textcolor{keyword}{inline} tainted<T, T\_Sbx> internal\_factory(T\_Rhs\&\& rhs)}
\DoxyCodeLine{973   \{}
\DoxyCodeLine{974     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<std::remove\_reference\_t<T\_Rhs>>) \{}
\DoxyCodeLine{975       \textcolor{keyword}{const} \textcolor{keywordtype}{void}* internal\_tag = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{976       \textcolor{keywordflow}{return} tainted(std::forward<T\_Rhs>(rhs), internal\_tag);}
\DoxyCodeLine{977     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{978       \textcolor{keywordflow}{return} tainted(std::forward<T\_Rhs>(rhs));}
\DoxyCodeLine{979     \}}
\DoxyCodeLine{980   \}}
\DoxyCodeLine{981 }
\DoxyCodeLine{982 \textcolor{keyword}{public}:}
\DoxyCodeLine{983   tainted() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{984   tainted(\textcolor{keyword}{const} tainted<T, T\_Sbx>\& p) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{985 }
\DoxyCodeLine{986   tainted(\textcolor{keyword}{const} tainted\_volatile<T, T\_Sbx>\& p)}
\DoxyCodeLine{987   \{}
\DoxyCodeLine{988     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{989     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{990     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{991     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{992     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* p\_data\_ref = \&p.get\_sandbox\_value\_ref();}
\DoxyCodeLine{993     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(p\_data\_ref);}
\DoxyCodeLine{994     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{995     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{996                            adjust\_type\_direction::TO\_APPLICATION,}
\DoxyCodeLine{997                            adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{998       get\_raw\_value\_ref(),}
\DoxyCodeLine{999       p.get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1000       example\_unsandboxed\_ptr,}
\DoxyCodeLine{1001       \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1002   \}}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004   \textcolor{comment}{// Initializing with a pointer is dangerous and permitted only internally}}
\DoxyCodeLine{1005   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T, RLBOX\_ENABLE\_IF(std::is\_po\textcolor{keywordtype}{int}er\_v<T2>)>}
\DoxyCodeLine{1006   tainted(T2 val)}
\DoxyCodeLine{1007     : data(val)}
\DoxyCodeLine{1008   \{}
\DoxyCodeLine{1009     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1010       std::is\_pointer\_v<T2>,}
\DoxyCodeLine{1011       \textcolor{stringliteral}{"{}Assignment of pointers is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1012       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1013       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1014       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1015       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1016       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1017       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1018       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1019       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1020       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1021       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1022       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1023       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1024       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1025       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}}}
\DoxyCodeLine{1026       \textcolor{stringliteral}{"{}4) For raw pointers, use assign\_raw\_pointer which performs required "{}}}
\DoxyCodeLine{1027       \textcolor{stringliteral}{"{}safety checks\(\backslash\)n "{}});}
\DoxyCodeLine{1028   \}}
\DoxyCodeLine{1029 }
\DoxyCodeLine{1030   tainted(}
\DoxyCodeLine{1031     \textcolor{keyword}{const} sandbox\_callback<}
\DoxyCodeLine{1032       detail::function\_ptr\_t<T> \textcolor{comment}{// Need to ensure we never generate code that}}
\DoxyCodeLine{1033                                 \textcolor{comment}{// creates a sandbox\_callback of a non function}}
\DoxyCodeLine{1034       ,}
\DoxyCodeLine{1035       T\_Sbx>\&)}
\DoxyCodeLine{1036   \{}
\DoxyCodeLine{1037     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1038       detail::true\_v<T>,}
\DoxyCodeLine{1039       \textcolor{stringliteral}{"{}RLBox does not support assigning sandbox\_callback values to tainted "{}}}
\DoxyCodeLine{1040       \textcolor{stringliteral}{"{}types (i.e. types that live in application memory).\(\backslash\)n"{}}}
\DoxyCodeLine{1041       \textcolor{stringliteral}{"{}If you still want to do this, consider changing your code to store the "{}}}
\DoxyCodeLine{1042       \textcolor{stringliteral}{"{}value in sandbox memory as follows. Convert\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1043       \textcolor{stringliteral}{"{}sandbox\_callback<T\_Func, Sbx> cb = ...;\(\backslash\)n"{}}}
\DoxyCodeLine{1044       \textcolor{stringliteral}{"{}tainted<T\_Func, Sbx> foo = cb;\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1045       \textcolor{stringliteral}{"{}to\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1046       \textcolor{stringliteral}{"{}tainted<T\_Func*, Sbx> foo\_ptr = sandbox.malloc\_in\_sandbox<T\_Func*>();\(\backslash\)n"{}}}
\DoxyCodeLine{1047       \textcolor{stringliteral}{"{}*foo\_ptr = cb;\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1048       \textcolor{stringliteral}{"{}This would keep the assignment in sandbox memory"{}});}
\DoxyCodeLine{1049   \}}
\DoxyCodeLine{1050 }
\DoxyCodeLine{1051   tainted(\textcolor{keyword}{const} std::nullptr\_t\& arg)}
\DoxyCodeLine{1052     : data(arg)}
\DoxyCodeLine{1053   \{}
\DoxyCodeLine{1054     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{1055   \}}
\DoxyCodeLine{1056 }
\DoxyCodeLine{1057   \textcolor{comment}{// We explicitly disable this constructor if it has one of the signatures}}
\DoxyCodeLine{1058   \textcolor{comment}{// above, so that we give the above constructors a higher priority. We only}}
\DoxyCodeLine{1059   \textcolor{comment}{// allow this for fundamental types as this is potentially unsafe for pointers}}
\DoxyCodeLine{1060   \textcolor{comment}{// and structs}}
\DoxyCodeLine{1061   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Arg,}
\DoxyCodeLine{1062            RLBOX\_ENABLE\_IF(}
\DoxyCodeLine{1063              !detail::rlbox\_is\_wrapper\_v<std::remove\_reference\_t<T\_Arg>> \&\&}
\DoxyCodeLine{1064              detail::is\_fundamental\_or\_enum\_v<T> \&\&}
\DoxyCodeLine{1065              detail::is\_fundamental\_or\_enum\_v<std::remove\_reference\_t<T\_Arg>>)>}
\DoxyCodeLine{1066   tainted(T\_Arg\&\& arg)}
\DoxyCodeLine{1067     : data(std::forward<T\_Arg>(arg))}
\DoxyCodeLine{1068   \{\}}
\DoxyCodeLine{1069 }
\DoxyCodeLine{1070   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{1071   \textcolor{keywordtype}{void} assign\_raw\_pointer(rlbox\_sandbox<T\_Sbx>\& sandbox, T\_Rhs val)}
\DoxyCodeLine{1072   \{}
\DoxyCodeLine{1073     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T\_Rhs>, \textcolor{stringliteral}{"{}Must be a pointer"{}});}
\DoxyCodeLine{1074     \textcolor{keyword}{static\_assert}(std::is\_assignable\_v<T\&, T\_Rhs>,}
\DoxyCodeLine{1075                   \textcolor{stringliteral}{"{}Should assign pointers of compatible types."{}});}
\DoxyCodeLine{1076     \textcolor{comment}{// Maybe a function pointer, so we need to cast}}
\DoxyCodeLine{1077     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* cast\_val = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(val);}
\DoxyCodeLine{1078     \textcolor{keywordtype}{bool} safe = sandbox.is\_pointer\_in\_sandbox\_memory(cast\_val);}
\DoxyCodeLine{1079     detail::dynamic\_check(}
\DoxyCodeLine{1080       safe,}
\DoxyCodeLine{1081       \textcolor{stringliteral}{"{}Tried to assign a pointer that is not in the sandbox.\(\backslash\)n "{}}}
\DoxyCodeLine{1082       \textcolor{stringliteral}{"{}This is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1083       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1084       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1085       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1086       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1087       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1088       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1089       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1090       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1091       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1092       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1093       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1094       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1095       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1096       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}});}
\DoxyCodeLine{1097     data = val;}
\DoxyCodeLine{1098   \}}
\DoxyCodeLine{1099 }
\DoxyCodeLine{1100   \textcolor{keyword}{inline} tainted\_opaque<T, T\_Sbx> to\_opaque()}
\DoxyCodeLine{1101   \{}
\DoxyCodeLine{1102     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}tainted\_opaque<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this});}
\DoxyCodeLine{1103   \}}
\DoxyCodeLine{1104 }
\DoxyCodeLine{1105   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Dummy = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1106   \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const}}
\DoxyCodeLine{1107 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1108     if\_constexpr\_named(cond1, std::is\_pointer\_v<T>)}
\DoxyCodeLine{1109     \{}
\DoxyCodeLine{1110       \textcolor{comment}{// We return this without the tainted wrapper as the checking for null}}
\DoxyCodeLine{1111       \textcolor{comment}{// doesn't really "{}induce"{} tainting in the application If the}}
\DoxyCodeLine{1112       \textcolor{comment}{// application is checking this pointer for null, then it is robust to}}
\DoxyCodeLine{1113       \textcolor{comment}{// this pointer being null or not null}}
\DoxyCodeLine{1114       \textcolor{keywordflow}{return} get\_raw\_value() != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1115     \}}
\DoxyCodeLine{1116     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1117     \{}
\DoxyCodeLine{1118       \textcolor{keyword}{auto} unknownCase = !(cond1);}
\DoxyCodeLine{1119       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1120         unknownCase,}
\DoxyCodeLine{1121         \textcolor{stringliteral}{"{}Implicit conversion to bool is only permitted for pointer types. For "{}}}
\DoxyCodeLine{1122         \textcolor{stringliteral}{"{}other types, unwrap the tainted value with the copy\_and\_verify API "{}}}
\DoxyCodeLine{1123         \textcolor{stringliteral}{"{}and then perform the required checks"{}});}
\DoxyCodeLine{1124     \}}
\DoxyCodeLine{1125   \}}
\DoxyCodeLine{1126 \};}
\DoxyCodeLine{1127 }
\DoxyCodeLine{1128 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{1129 \textcolor{keyword}{inline} tainted<T, T\_Sbx> from\_opaque(tainted\_opaque<T, T\_Sbx> val)}
\DoxyCodeLine{1130 \{}
\DoxyCodeLine{1131   \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}tainted<T, T\_Sbx>*\textcolor{keyword}{>}(\&val);}
\DoxyCodeLine{1132 \}}
\DoxyCodeLine{1133 }
\DoxyCodeLine{1138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{1139 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}} : \textcolor{keyword}{public} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl}}<tainted\_volatile, T, T\_Sbx>}
\DoxyCodeLine{1140 \{}
\DoxyCodeLine{1141   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{1142   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{1143 }
\DoxyCodeLine{1144   \textcolor{comment}{// Classes recieve their own specialization}}
\DoxyCodeLine{1145   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1146     !std::is\_class\_v<T>,}
\DoxyCodeLine{1147     \textcolor{stringliteral}{"{}Missing definition for class T. This error occurs for one "{}}}
\DoxyCodeLine{1148     \textcolor{stringliteral}{"{}of 2 reasons.\(\backslash\)n"{}}}
\DoxyCodeLine{1149     \textcolor{stringliteral}{"{}  1) Make sure you have include a call rlbox\_load\_structs\_from\_library "{}}}
\DoxyCodeLine{1150     \textcolor{stringliteral}{"{}for this library with this class included.\(\backslash\)n"{}}}
\DoxyCodeLine{1151     \textcolor{stringliteral}{"{}  2) Make sure you run (re-\/run) the struct-\/dump tool to list "{}}}
\DoxyCodeLine{1152     \textcolor{stringliteral}{"{}all structs in use by your program.\(\backslash\)n"{}});}
\DoxyCodeLine{1153 }
\DoxyCodeLine{1154   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1155     detail::is\_basic\_type\_v<T> || std::is\_array\_v<T>,}
\DoxyCodeLine{1156     \textcolor{stringliteral}{"{}Tainted types only support fundamental, enum, pointer, array and struct "{}}}
\DoxyCodeLine{1157     \textcolor{stringliteral}{"{}types. Please file a bug if more support is needed."{}});}
\DoxyCodeLine{1158 }
\DoxyCodeLine{1159 \textcolor{keyword}{private}:}
\DoxyCodeLine{1160   \textcolor{keyword}{using} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{T\_ClassBase}} = \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl<tainted\_volatile, T, T\_Sbx>}};}
\DoxyCodeLine{1161   \textcolor{keyword}{using} T\_AppType = tainted\_detail::tainted\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{1162   \textcolor{keyword}{using} T\_SandboxedType = tainted\_detail::tainted\_vol\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{1163   T\_SandboxedType data;}
\DoxyCodeLine{1164 }
\DoxyCodeLine{1165   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_sandbox\_value\_ref() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{1166   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_sandbox\_value\_ref() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{1167 }
\DoxyCodeLine{1168   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value()\textcolor{keyword}{ const}}
\DoxyCodeLine{1169 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1170     std::remove\_cv\_t<T\_AppType> ret;}
\DoxyCodeLine{1171     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{1172     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{1173     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{1174     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{1175     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* data\_ref = \&data;}
\DoxyCodeLine{1176     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(data\_ref);}
\DoxyCodeLine{1177     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1178     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1179                            adjust\_type\_direction::TO\_APPLICATION,}
\DoxyCodeLine{1180                            adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1181       ret, data, example\_unsandboxed\_ptr, \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1182     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{1183   \}}
\DoxyCodeLine{1184 }
\DoxyCodeLine{1185   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value()}
\DoxyCodeLine{1186     \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1187   \{}
\DoxyCodeLine{1188     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{1189   \};}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{1192     \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1193   \{}
\DoxyCodeLine{1194     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{1195     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{1196   \};}
\DoxyCodeLine{1197 }
\DoxyCodeLine{1198   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value()}
\DoxyCodeLine{1199   \{}
\DoxyCodeLine{1200     rlbox\_detail\_forward\_to\_const(get\_raw\_value, std::remove\_cv\_t<T\_AppType>);}
\DoxyCodeLine{1201   \}}
\DoxyCodeLine{1202 }
\DoxyCodeLine{1203   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1204   \{}
\DoxyCodeLine{1205     rlbox\_detail\_forward\_to\_const(get\_raw\_sandbox\_value,}
\DoxyCodeLine{1206                                   std::remove\_cv\_t<T\_SandboxedType>);}
\DoxyCodeLine{1207   \};}
\DoxyCodeLine{1208 }
\DoxyCodeLine{1209   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{1210     \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1211   \{}
\DoxyCodeLine{1212     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{1213     rlbox\_detail\_forward\_to\_const(get\_raw\_sandbox\_value,}
\DoxyCodeLine{1214                                   std::remove\_cv\_t<T\_SandboxedType>);}
\DoxyCodeLine{1215   \};}
\DoxyCodeLine{1216 }
\DoxyCodeLine{1217   \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1218   \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile<T, T\_Sbx>}}\& p) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{keyword}{public}:}
\DoxyCodeLine{1221   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<const T*, T\_Sbx>}} operator\&() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1222   \{}
\DoxyCodeLine{1223     \textcolor{keyword}{auto} ref =}
\DoxyCodeLine{1224       detail::remove\_volatile\_from\_ptr\_cast(\&this-\/>get\_sandbox\_value\_ref());}
\DoxyCodeLine{1225     \textcolor{keyword}{auto} ref\_cast = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T*\textcolor{keyword}{>}(ref);}
\DoxyCodeLine{1226     \textcolor{keyword}{auto} ret = \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<const T*, T\_Sbx>::internal\_factory}}(ref\_cast);}
\DoxyCodeLine{1227     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{1228   \}}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T*, T\_Sbx>}} operator\&() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1231   \{}
\DoxyCodeLine{1232     \textcolor{keyword}{using} T\_Ret = \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T*, T\_Sbx>}};}
\DoxyCodeLine{1233     rlbox\_detail\_forward\_to\_const(\textcolor{keyword}{operator}\&, T\_Ret);}
\DoxyCodeLine{1234   \}}
\DoxyCodeLine{1235 }
\DoxyCodeLine{1236   \textcolor{comment}{// Needed as the definition of unary \& above shadows the base's binary \&}}
\DoxyCodeLine{1237   rlbox\_detail\_forward\_binop\_to\_base(\&, \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{T\_ClassBase}});}
\DoxyCodeLine{1238 }
\DoxyCodeLine{1239   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_RhsRef>}
\DoxyCodeLine{1240   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile<T, T\_Sbx>}}\& operator=(T\_RhsRef\&\& val)}
\DoxyCodeLine{1241   \{}
\DoxyCodeLine{1242     \textcolor{keyword}{using} T\_Rhs = std::remove\_reference\_t<T\_RhsRef>;}
\DoxyCodeLine{1243     \textcolor{keyword}{using} T\_Rhs\_El = std::remove\_all\_extents\_t<T\_Rhs>;}
\DoxyCodeLine{1244 }
\DoxyCodeLine{1245     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{1246     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{1247     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{1248     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{1249     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* data\_ref = \&get\_sandbox\_value\_ref();}
\DoxyCodeLine{1250     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(data\_ref);}
\DoxyCodeLine{1251     \textcolor{comment}{// Some branches don't use this}}
\DoxyCodeLine{1252     RLBOX\_UNUSED(example\_unsandboxed\_ptr);}
\DoxyCodeLine{1253 }
\DoxyCodeLine{1254     if\_constexpr\_named(}
\DoxyCodeLine{1255       cond1, std::is\_same\_v<std::remove\_const\_t<T\_Rhs>, std::nullptr\_t>)}
\DoxyCodeLine{1256     \{}
\DoxyCodeLine{1257       \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{1258                     \textcolor{stringliteral}{"{}Null pointer can only be assigned to pointers"{}});}
\DoxyCodeLine{1259       \textcolor{comment}{// assign using an integer instead of nullptr, as the pointer field may be}}
\DoxyCodeLine{1260       \textcolor{comment}{// represented as integer}}
\DoxyCodeLine{1261       data = 0;}
\DoxyCodeLine{1262     \}}
\DoxyCodeLine{1263     \textcolor{keywordflow}{else} if\_constexpr\_named(cond2, detail::rlbox\_is\_tainted\_v<T\_Rhs>)}
\DoxyCodeLine{1264     \{}
\DoxyCodeLine{1265       \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1266       convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1267                              adjust\_type\_direction::TO\_SANDBOX,}
\DoxyCodeLine{1268                              adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1269         get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1270         val.get\_raw\_value\_ref(),}
\DoxyCodeLine{1271         example\_unsandboxed\_ptr,}
\DoxyCodeLine{1272         \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1273     \}}
\DoxyCodeLine{1274     \textcolor{keywordflow}{else} if\_constexpr\_named(cond3, detail::rlbox\_is\_tainted\_volatile\_v<T\_Rhs>)}
\DoxyCodeLine{1275     \{}
\DoxyCodeLine{1276       \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1277       convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1278                              adjust\_type\_direction::NO\_CHANGE,}
\DoxyCodeLine{1279                              adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1280         get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1281         val.get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1282         example\_unsandboxed\_ptr,}
\DoxyCodeLine{1283         \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1284     \}}
\DoxyCodeLine{1285     \textcolor{keywordflow}{else} if\_constexpr\_named(cond4, detail::rlbox\_is\_sandbox\_callback\_v<T\_Rhs>)}
\DoxyCodeLine{1286     \{}
\DoxyCodeLine{1287       \textcolor{keyword}{using} T\_RhsFunc = detail::rlbox\_remove\_wrapper\_t<T\_Rhs>;}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289       \textcolor{comment}{// need to perform some typechecking to ensure we are assigning compatible}}
\DoxyCodeLine{1290       \textcolor{comment}{// function pointer types only}}
\DoxyCodeLine{1291       if\_constexpr\_named(subcond1, !std::is\_assignable\_v<T\&, T\_RhsFunc>)}
\DoxyCodeLine{1292       \{}
\DoxyCodeLine{1293         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1294           subcond1,}
\DoxyCodeLine{1295           \textcolor{stringliteral}{"{}Trying to assign function pointer to field of incompatible types"{}});}
\DoxyCodeLine{1296       \}}
\DoxyCodeLine{1297       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1298       \{}
\DoxyCodeLine{1299         \textcolor{comment}{// Need to reinterpret\_cast as the representation of the signature of a}}
\DoxyCodeLine{1300         \textcolor{comment}{// callback uses the machine model of the sandbox, while the field uses}}
\DoxyCodeLine{1301         \textcolor{comment}{// that of the application. But we have already checked above that this}}
\DoxyCodeLine{1302         \textcolor{comment}{// is safe.}}
\DoxyCodeLine{1303         \textcolor{keyword}{auto} func = val.get\_raw\_sandbox\_value();}
\DoxyCodeLine{1304         \textcolor{keyword}{using} T\_Cast = std::remove\_volatile\_t<T\_SandboxedType>;}
\DoxyCodeLine{1305         get\_sandbox\_value\_ref() = (T\_Cast)func;}
\DoxyCodeLine{1306       \}}
\DoxyCodeLine{1307     \}}
\DoxyCodeLine{1308     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{1309       cond5,}
\DoxyCodeLine{1310       detail::is\_fundamental\_or\_enum\_v<T> ||}
\DoxyCodeLine{1311         (std::is\_array\_v<T> \&\& !std::is\_pointer\_v<T\_Rhs\_El>))}
\DoxyCodeLine{1312     \{}
\DoxyCodeLine{1313       detail::convert\_type\_fundamental\_or\_array(get\_sandbox\_value\_ref(), val);}
\DoxyCodeLine{1314     \}}
\DoxyCodeLine{1315     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{1316       cond6, std::is\_pointer\_v<T\_Rhs> || std::is\_pointer\_v<T\_Rhs\_El>)}
\DoxyCodeLine{1317     \{}
\DoxyCodeLine{1318       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1319         cond6,}
\DoxyCodeLine{1320         \textcolor{stringliteral}{"{}Assignment of pointers is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1321         \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1322         \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1323         \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1324         \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1325         \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1326         \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1327         \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1328         \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1329         \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1330         \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1331         \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1332         \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1333         \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1334         \textcolor{stringliteral}{"{}address\(\backslash\)n "{}}}
\DoxyCodeLine{1335         \textcolor{stringliteral}{"{}4) For raw pointers, use assign\_raw\_pointer which performs required "{}}}
\DoxyCodeLine{1336         \textcolor{stringliteral}{"{}safety checks\(\backslash\)n "{}});}
\DoxyCodeLine{1337     \}}
\DoxyCodeLine{1338     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1339     \{}
\DoxyCodeLine{1340       \textcolor{keyword}{auto} unknownCase =}
\DoxyCodeLine{1341         !(cond1 || cond2 || cond3 || cond4 || cond5 \textcolor{comment}{/* || cond6 */});}
\DoxyCodeLine{1342       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1343         unknownCase, \textcolor{stringliteral}{"{}Assignment of the given type of value is not supported"{}});}
\DoxyCodeLine{1344     \}}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1347   \}}
\DoxyCodeLine{1348 }
\DoxyCodeLine{1349   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{1350   \textcolor{keywordtype}{void} assign\_raw\_pointer(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox, T\_Rhs val)}
\DoxyCodeLine{1351   \{}
\DoxyCodeLine{1352     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T\_Rhs>, \textcolor{stringliteral}{"{}Must be a pointer"{}});}
\DoxyCodeLine{1353     \textcolor{keyword}{static\_assert}(std::is\_assignable\_v<T\&, T\_Rhs>,}
\DoxyCodeLine{1354                   \textcolor{stringliteral}{"{}Should assign pointers of compatible types."{}});}
\DoxyCodeLine{1355     \textcolor{comment}{// Maybe a function pointer, so we need to cast}}
\DoxyCodeLine{1356     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* cast\_val = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(val);}
\DoxyCodeLine{1357     \textcolor{keywordtype}{bool} safe = sandbox.\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox_a55e48f0300c16d36ea7ed5a7e4750f64}{is\_pointer\_in\_sandbox\_memory}}(cast\_val);}
\DoxyCodeLine{1358     detail::dynamic\_check(}
\DoxyCodeLine{1359       safe,}
\DoxyCodeLine{1360       \textcolor{stringliteral}{"{}Tried to assign a pointer that is not in the sandbox.\(\backslash\)n "{}}}
\DoxyCodeLine{1361       \textcolor{stringliteral}{"{}This is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1362       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1363       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1364       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1365       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1366       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1367       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1368       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1369       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1370       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1371       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1372       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1373       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1374       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1375       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}});}
\DoxyCodeLine{1376     get\_sandbox\_value\_ref() =}
\DoxyCodeLine{1377       sandbox.template get\_sandboxed\_pointer<T\_Rhs>(cast\_val);}
\DoxyCodeLine{1378   \}}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Dummy = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1381   \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const}}
\DoxyCodeLine{1382 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1383     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1384       detail::true\_v<T\_Dummy>,}
\DoxyCodeLine{1385       \textcolor{stringliteral}{"{}Cannot apply implicit conversion to bool on values that are located in "{}}}
\DoxyCodeLine{1386       \textcolor{stringliteral}{"{}sandbox memory. This error occurs if you compare a dereferenced value "{}}}
\DoxyCodeLine{1387       \textcolor{stringliteral}{"{}such as the code shown below\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1388       \textcolor{stringliteral}{"{}tainted<int**> a = ...;\(\backslash\)n"{}}}
\DoxyCodeLine{1389       \textcolor{stringliteral}{"{}assert(*a);\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1390       \textcolor{stringliteral}{"{}Instead you can write this code as \(\backslash\)n"{}}}
\DoxyCodeLine{1391       \textcolor{stringliteral}{"{}tainted<int*> temp = *a;\(\backslash\)n"{}}}
\DoxyCodeLine{1392       \textcolor{stringliteral}{"{}assert(temp);\(\backslash\)n"{}});}
\DoxyCodeLine{1393     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1394   \}}
\DoxyCodeLine{1395 \};}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397 \}}

\end{DoxyCode}
